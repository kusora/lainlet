// Code generated by protoc-gen-go. DO NOT EDIT.
// source: message.proto

/*
Package message is a generated protocol buffer package.

It is generated from these files:
	message.proto

It has these top-level messages:
	AppnameRequest
	AppnameReply
	AppInfo
	AppsReply
	AppsRequest
	ContainerForBackupctl
	PodInfoForBackupctl
	BackupctlReply
	BackupctlRequest
	ConfigRequest
	ConfigReply
	Info
	ContainersReply
	ContainersRequest
	Container
	Dependency
	PodInfo
	CoreInfo
	CoreinfoReply
	CoreinfoRequest
	ContainerInfo
	DependsItem
	DependsAppMap
	DependsNodeMap
	DependsReply
	DependsRequest
	LocalspecReply
	LocalspecRequest
	NodeInfo
	NodesReply
	NodesRequest
	Pod
	PodGroup
	PodgroupReply
	PodgroupRequest
	ContainerForProxy
	ProcInfo
	ProxyReply
	ProxyRequest
	PodInfoForRebellion
	CoreInfoForRebellion
	RebellionLocalprocsReply
	RebellionLocalprocsRequest
	StreamrouterPortsRequest
	StreamrouterPortsReply
	StreamUpstream
	StreamService
	StreamProc
	StreamProcList
	Port
	Annotation
	StreamrouterStreamprocsReply
	StreamrouterStreamprocsRequest
	ContainerForWebrouter
	PodInfoForWebrouter
	CoreInfoForWebrouter
	WebrouterWebprocsReply
	WebrouterWebprocsRequest
	EmptyRequest
	VersionReply
	WatcherStatus
	StatusReply
*/
package message

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type NodeInfo_Value_Type int32

const (
	NodeInfo_Value_STRING NodeInfo_Value_Type = 0
	NodeInfo_Value_MAP    NodeInfo_Value_Type = 1
)

var NodeInfo_Value_Type_name = map[int32]string{
	0: "STRING",
	1: "MAP",
}
var NodeInfo_Value_Type_value = map[string]int32{
	"STRING": 0,
	"MAP":    1,
}

func (x NodeInfo_Value_Type) String() string {
	return proto.EnumName(NodeInfo_Value_Type_name, int32(x))
}
func (NodeInfo_Value_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{28, 0, 0} }

type AppnameRequest struct {
	Ip string `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
}

func (m *AppnameRequest) Reset()                    { *m = AppnameRequest{} }
func (m *AppnameRequest) String() string            { return proto.CompactTextString(m) }
func (*AppnameRequest) ProtoMessage()               {}
func (*AppnameRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AppnameRequest) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

type AppnameReply struct {
	Data map[string]string `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AppnameReply) Reset()                    { *m = AppnameReply{} }
func (m *AppnameReply) String() string            { return proto.CompactTextString(m) }
func (*AppnameReply) ProtoMessage()               {}
func (*AppnameReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AppnameReply) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

type AppInfo struct {
	Appname string `protobuf:"bytes,1,opt,name=Appname" json:"Appname,omitempty"`
}

func (m *AppInfo) Reset()                    { *m = AppInfo{} }
func (m *AppInfo) String() string            { return proto.CompactTextString(m) }
func (*AppInfo) ProtoMessage()               {}
func (*AppInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AppInfo) GetAppname() string {
	if m != nil {
		return m.Appname
	}
	return ""
}

type AppsReply struct {
	Data map[string]*AppInfo `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AppsReply) Reset()                    { *m = AppsReply{} }
func (m *AppsReply) String() string            { return proto.CompactTextString(m) }
func (*AppsReply) ProtoMessage()               {}
func (*AppsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AppsReply) GetData() map[string]*AppInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type AppsRequest struct {
}

func (m *AppsRequest) Reset()                    { *m = AppsRequest{} }
func (m *AppsRequest) String() string            { return proto.CompactTextString(m) }
func (*AppsRequest) ProtoMessage()               {}
func (*AppsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type ContainerForBackupctl struct {
	Id       string `protobuf:"bytes,1,opt,name=Id" json:"Id,omitempty"`
	Ip       string `protobuf:"bytes,2,opt,name=Ip" json:"Ip,omitempty"`
	NodeIp   string `protobuf:"bytes,3,opt,name=NodeIp" json:"NodeIp,omitempty"`
	NodeName string `protobuf:"bytes,4,opt,name=NodeName" json:"NodeName,omitempty"`
}

func (m *ContainerForBackupctl) Reset()                    { *m = ContainerForBackupctl{} }
func (m *ContainerForBackupctl) String() string            { return proto.CompactTextString(m) }
func (*ContainerForBackupctl) ProtoMessage()               {}
func (*ContainerForBackupctl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ContainerForBackupctl) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ContainerForBackupctl) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *ContainerForBackupctl) GetNodeIp() string {
	if m != nil {
		return m.NodeIp
	}
	return ""
}

func (m *ContainerForBackupctl) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

type PodInfoForBackupctl struct {
	Annotation string                   `protobuf:"bytes,1,opt,name=Annotation" json:"Annotation,omitempty"`
	Containers []*ContainerForBackupctl `protobuf:"bytes,2,rep,name=Containers" json:"Containers,omitempty"`
	InstanceNo int32                    `protobuf:"varint,3,opt,name=InstanceNo" json:"InstanceNo,omitempty"`
}

func (m *PodInfoForBackupctl) Reset()                    { *m = PodInfoForBackupctl{} }
func (m *PodInfoForBackupctl) String() string            { return proto.CompactTextString(m) }
func (*PodInfoForBackupctl) ProtoMessage()               {}
func (*PodInfoForBackupctl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PodInfoForBackupctl) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}

func (m *PodInfoForBackupctl) GetContainers() []*ContainerForBackupctl {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *PodInfoForBackupctl) GetInstanceNo() int32 {
	if m != nil {
		return m.InstanceNo
	}
	return 0
}

type BackupctlReply struct {
	Data map[string]*BackupctlReply_PodInfoList `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *BackupctlReply) Reset()                    { *m = BackupctlReply{} }
func (m *BackupctlReply) String() string            { return proto.CompactTextString(m) }
func (*BackupctlReply) ProtoMessage()               {}
func (*BackupctlReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *BackupctlReply) GetData() map[string]*BackupctlReply_PodInfoList {
	if m != nil {
		return m.Data
	}
	return nil
}

type BackupctlReply_PodInfoList struct {
	Pods []*PodInfoForBackupctl `protobuf:"bytes,1,rep,name=pods" json:"pods,omitempty"`
}

func (m *BackupctlReply_PodInfoList) Reset()                    { *m = BackupctlReply_PodInfoList{} }
func (m *BackupctlReply_PodInfoList) String() string            { return proto.CompactTextString(m) }
func (*BackupctlReply_PodInfoList) ProtoMessage()               {}
func (*BackupctlReply_PodInfoList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *BackupctlReply_PodInfoList) GetPods() []*PodInfoForBackupctl {
	if m != nil {
		return m.Pods
	}
	return nil
}

type BackupctlRequest struct {
	Appname string `protobuf:"bytes,1,opt,name=Appname" json:"Appname,omitempty"`
}

func (m *BackupctlRequest) Reset()                    { *m = BackupctlRequest{} }
func (m *BackupctlRequest) String() string            { return proto.CompactTextString(m) }
func (*BackupctlRequest) ProtoMessage()               {}
func (*BackupctlRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *BackupctlRequest) GetAppname() string {
	if m != nil {
		return m.Appname
	}
	return ""
}

type ConfigRequest struct {
	Target string `protobuf:"bytes,1,opt,name=Target" json:"Target,omitempty"`
}

func (m *ConfigRequest) Reset()                    { *m = ConfigRequest{} }
func (m *ConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*ConfigRequest) ProtoMessage()               {}
func (*ConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ConfigRequest) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

type ConfigReply struct {
	Data map[string]string `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ConfigReply) Reset()                    { *m = ConfigReply{} }
func (m *ConfigReply) String() string            { return proto.CompactTextString(m) }
func (*ConfigReply) ProtoMessage()               {}
func (*ConfigReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ConfigReply) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

type Info struct {
	AppName    string `protobuf:"bytes,1,opt,name=AppName" json:"AppName,omitempty"`
	AppVersion string `protobuf:"bytes,2,opt,name=AppVersion" json:"AppVersion,omitempty"`
	ProcName   string `protobuf:"bytes,3,opt,name=ProcName" json:"ProcName,omitempty"`
	NodeName   string `protobuf:"bytes,4,opt,name=NodeName" json:"NodeName,omitempty"`
	NodeIP     string `protobuf:"bytes,5,opt,name=NodeIP" json:"NodeIP,omitempty"`
	IP         string `protobuf:"bytes,6,opt,name=IP" json:"IP,omitempty"`
	Port       int32  `protobuf:"varint,7,opt,name=Port" json:"Port,omitempty"`
	InstanceNo int32  `protobuf:"varint,8,opt,name=InstanceNo" json:"InstanceNo,omitempty"`
}

func (m *Info) Reset()                    { *m = Info{} }
func (m *Info) String() string            { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()               {}
func (*Info) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Info) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *Info) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *Info) GetProcName() string {
	if m != nil {
		return m.ProcName
	}
	return ""
}

func (m *Info) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *Info) GetNodeIP() string {
	if m != nil {
		return m.NodeIP
	}
	return ""
}

func (m *Info) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *Info) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Info) GetInstanceNo() int32 {
	if m != nil {
		return m.InstanceNo
	}
	return 0
}

type ContainersReply struct {
	Data map[string]*Info `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ContainersReply) Reset()                    { *m = ContainersReply{} }
func (m *ContainersReply) String() string            { return proto.CompactTextString(m) }
func (*ContainersReply) ProtoMessage()               {}
func (*ContainersReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ContainersReply) GetData() map[string]*Info {
	if m != nil {
		return m.Data
	}
	return nil
}

type ContainersRequest struct {
	Nodename string `protobuf:"bytes,1,opt,name=Nodename" json:"Nodename,omitempty"`
}

func (m *ContainersRequest) Reset()                    { *m = ContainersRequest{} }
func (m *ContainersRequest) String() string            { return proto.CompactTextString(m) }
func (*ContainersRequest) ProtoMessage()               {}
func (*ContainersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ContainersRequest) GetNodename() string {
	if m != nil {
		return m.Nodename
	}
	return ""
}

type Container struct {
	Command  []string `protobuf:"bytes,1,rep,name=Command" json:"Command,omitempty"`
	Id       string   `protobuf:"bytes,2,opt,name=Id" json:"Id,omitempty"`
	Ip       string   `protobuf:"bytes,3,opt,name=Ip" json:"Ip,omitempty"`
	Cpu      int32    `protobuf:"varint,4,opt,name=Cpu" json:"Cpu,omitempty"`
	Env      []string `protobuf:"bytes,5,rep,name=Env" json:"Env,omitempty"`
	Expose   int32    `protobuf:"varint,6,opt,name=Expose" json:"Expose,omitempty"`
	Image    string   `protobuf:"bytes,7,opt,name=Image" json:"Image,omitempty"`
	Memory   int64    `protobuf:"varint,8,opt,name=Memory" json:"Memory,omitempty"`
	NodeIp   string   `protobuf:"bytes,9,opt,name=NodeIp" json:"NodeIp,omitempty"`
	NodeName string   `protobuf:"bytes,10,opt,name=NodeName" json:"NodeName,omitempty"`
	Volumes  []string `protobuf:"bytes,11,rep,name=Volumes" json:"Volumes,omitempty"`
}

func (m *Container) Reset()                    { *m = Container{} }
func (m *Container) String() string            { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()               {}
func (*Container) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Container) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *Container) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Container) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Container) GetCpu() int32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *Container) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Container) GetExpose() int32 {
	if m != nil {
		return m.Expose
	}
	return 0
}

func (m *Container) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Container) GetMemory() int64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Container) GetNodeIp() string {
	if m != nil {
		return m.NodeIp
	}
	return ""
}

func (m *Container) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *Container) GetVolumes() []string {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type Dependency struct {
	PodName string `protobuf:"bytes,1,opt,name=PodName" json:"PodName,omitempty"`
	Policy  int32  `protobuf:"varint,2,opt,name=Policy" json:"Policy,omitempty"`
}

func (m *Dependency) Reset()                    { *m = Dependency{} }
func (m *Dependency) String() string            { return proto.CompactTextString(m) }
func (*Dependency) ProtoMessage()               {}
func (*Dependency) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Dependency) GetPodName() string {
	if m != nil {
		return m.PodName
	}
	return ""
}

func (m *Dependency) GetPolicy() int32 {
	if m != nil {
		return m.Policy
	}
	return 0
}

type PodInfo struct {
	Annotation   string        `protobuf:"bytes,1,opt,name=Annotation" json:"Annotation,omitempty"`
	Containers   []*Container  `protobuf:"bytes,2,rep,name=Containers" json:"Containers,omitempty"`
	Dependencies []*Dependency `protobuf:"bytes,3,rep,name=Dependencies" json:"Dependencies,omitempty"`
	InstanceNo   int32         `protobuf:"varint,4,opt,name=InstanceNo" json:"InstanceNo,omitempty"`
}

func (m *PodInfo) Reset()                    { *m = PodInfo{} }
func (m *PodInfo) String() string            { return proto.CompactTextString(m) }
func (*PodInfo) ProtoMessage()               {}
func (*PodInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *PodInfo) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}

func (m *PodInfo) GetContainers() []*Container {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *PodInfo) GetDependencies() []*Dependency {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

func (m *PodInfo) GetInstanceNo() int32 {
	if m != nil {
		return m.InstanceNo
	}
	return 0
}

type CoreInfo struct {
	PodInfos []*PodInfo `protobuf:"bytes,1,rep,name=PodInfos" json:"PodInfos,omitempty"`
}

func (m *CoreInfo) Reset()                    { *m = CoreInfo{} }
func (m *CoreInfo) String() string            { return proto.CompactTextString(m) }
func (*CoreInfo) ProtoMessage()               {}
func (*CoreInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *CoreInfo) GetPodInfos() []*PodInfo {
	if m != nil {
		return m.PodInfos
	}
	return nil
}

type CoreinfoReply struct {
	Data map[string]*CoreInfo `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CoreinfoReply) Reset()                    { *m = CoreinfoReply{} }
func (m *CoreinfoReply) String() string            { return proto.CompactTextString(m) }
func (*CoreinfoReply) ProtoMessage()               {}
func (*CoreinfoReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *CoreinfoReply) GetData() map[string]*CoreInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type CoreinfoRequest struct {
	Appname string `protobuf:"bytes,1,opt,name=Appname" json:"Appname,omitempty"`
}

func (m *CoreinfoRequest) Reset()                    { *m = CoreinfoRequest{} }
func (m *CoreinfoRequest) String() string            { return proto.CompactTextString(m) }
func (*CoreinfoRequest) ProtoMessage()               {}
func (*CoreinfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *CoreinfoRequest) GetAppname() string {
	if m != nil {
		return m.Appname
	}
	return ""
}

type ContainerInfo struct {
	ContainerID string `protobuf:"bytes,1,opt,name=ContainerID" json:"ContainerID,omitempty"`
	NodeIP      string `protobuf:"bytes,2,opt,name=NodeIP" json:"NodeIP,omitempty"`
	IP          string `protobuf:"bytes,3,opt,name=IP" json:"IP,omitempty"`
	Port        int32  `protobuf:"varint,4,opt,name=Port" json:"Port,omitempty"`
}

func (m *ContainerInfo) Reset()                    { *m = ContainerInfo{} }
func (m *ContainerInfo) String() string            { return proto.CompactTextString(m) }
func (*ContainerInfo) ProtoMessage()               {}
func (*ContainerInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *ContainerInfo) GetContainerID() string {
	if m != nil {
		return m.ContainerID
	}
	return ""
}

func (m *ContainerInfo) GetNodeIP() string {
	if m != nil {
		return m.NodeIP
	}
	return ""
}

func (m *ContainerInfo) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *ContainerInfo) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type DependsItem struct {
	Annotation string           `protobuf:"bytes,1,opt,name=Annotation" json:"Annotation,omitempty"`
	Containers []*ContainerInfo `protobuf:"bytes,2,rep,name=Containers" json:"Containers,omitempty"`
}

func (m *DependsItem) Reset()                    { *m = DependsItem{} }
func (m *DependsItem) String() string            { return proto.CompactTextString(m) }
func (*DependsItem) ProtoMessage()               {}
func (*DependsItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *DependsItem) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}

func (m *DependsItem) GetContainers() []*ContainerInfo {
	if m != nil {
		return m.Containers
	}
	return nil
}

type DependsAppMap struct {
	Apps map[string]*DependsItem `protobuf:"bytes,1,rep,name=apps" json:"apps,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DependsAppMap) Reset()                    { *m = DependsAppMap{} }
func (m *DependsAppMap) String() string            { return proto.CompactTextString(m) }
func (*DependsAppMap) ProtoMessage()               {}
func (*DependsAppMap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *DependsAppMap) GetApps() map[string]*DependsItem {
	if m != nil {
		return m.Apps
	}
	return nil
}

type DependsNodeMap struct {
	Nodes map[string]*DependsAppMap `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DependsNodeMap) Reset()                    { *m = DependsNodeMap{} }
func (m *DependsNodeMap) String() string            { return proto.CompactTextString(m) }
func (*DependsNodeMap) ProtoMessage()               {}
func (*DependsNodeMap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *DependsNodeMap) GetNodes() map[string]*DependsAppMap {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type DependsReply struct {
	Data map[string]*DependsNodeMap `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DependsReply) Reset()                    { *m = DependsReply{} }
func (m *DependsReply) String() string            { return proto.CompactTextString(m) }
func (*DependsReply) ProtoMessage()               {}
func (*DependsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *DependsReply) GetData() map[string]*DependsNodeMap {
	if m != nil {
		return m.Data
	}
	return nil
}

type DependsRequest struct {
	Target string `protobuf:"bytes,1,opt,name=Target" json:"Target,omitempty"`
}

func (m *DependsRequest) Reset()                    { *m = DependsRequest{} }
func (m *DependsRequest) String() string            { return proto.CompactTextString(m) }
func (*DependsRequest) ProtoMessage()               {}
func (*DependsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *DependsRequest) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

type LocalspecReply struct {
	Data    []string `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty"`
	LocalIP string   `protobuf:"bytes,2,opt,name=LocalIP" json:"LocalIP,omitempty"`
	Ip      string   `protobuf:"bytes,3,opt,name=ip" json:"ip,omitempty"`
}

func (m *LocalspecReply) Reset()                    { *m = LocalspecReply{} }
func (m *LocalspecReply) String() string            { return proto.CompactTextString(m) }
func (*LocalspecReply) ProtoMessage()               {}
func (*LocalspecReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *LocalspecReply) GetData() []string {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *LocalspecReply) GetLocalIP() string {
	if m != nil {
		return m.LocalIP
	}
	return ""
}

func (m *LocalspecReply) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

type LocalspecRequest struct {
	Nodeip string `protobuf:"bytes,1,opt,name=Nodeip" json:"Nodeip,omitempty"`
}

func (m *LocalspecRequest) Reset()                    { *m = LocalspecRequest{} }
func (m *LocalspecRequest) String() string            { return proto.CompactTextString(m) }
func (*LocalspecRequest) ProtoMessage()               {}
func (*LocalspecRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *LocalspecRequest) GetNodeip() string {
	if m != nil {
		return m.Nodeip
	}
	return ""
}

type NodeInfo struct {
	V map[string]*NodeInfo_Value `protobuf:"bytes,1,rep,name=v" json:"v,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NodeInfo) Reset()                    { *m = NodeInfo{} }
func (m *NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()               {}
func (*NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *NodeInfo) GetV() map[string]*NodeInfo_Value {
	if m != nil {
		return m.V
	}
	return nil
}

// Value can be a string or a map of type map[string]string
type NodeInfo_Value struct {
	Vtype NodeInfo_Value_Type `protobuf:"varint,1,opt,name=Vtype,enum=message.NodeInfo_Value_Type" json:"Vtype,omitempty"`
	Sval  string              `protobuf:"bytes,2,opt,name=sval" json:"sval,omitempty"`
	Mval  map[string]string   `protobuf:"bytes,3,rep,name=mval" json:"mval,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NodeInfo_Value) Reset()                    { *m = NodeInfo_Value{} }
func (m *NodeInfo_Value) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo_Value) ProtoMessage()               {}
func (*NodeInfo_Value) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28, 0} }

func (m *NodeInfo_Value) GetVtype() NodeInfo_Value_Type {
	if m != nil {
		return m.Vtype
	}
	return NodeInfo_Value_STRING
}

func (m *NodeInfo_Value) GetSval() string {
	if m != nil {
		return m.Sval
	}
	return ""
}

func (m *NodeInfo_Value) GetMval() map[string]string {
	if m != nil {
		return m.Mval
	}
	return nil
}

type NodesReply struct {
	Data map[string]*NodeInfo `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NodesReply) Reset()                    { *m = NodesReply{} }
func (m *NodesReply) String() string            { return proto.CompactTextString(m) }
func (*NodesReply) ProtoMessage()               {}
func (*NodesReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *NodesReply) GetData() map[string]*NodeInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type NodesRequest struct {
	Name string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
}

func (m *NodesRequest) Reset()                    { *m = NodesRequest{} }
func (m *NodesRequest) String() string            { return proto.CompactTextString(m) }
func (*NodesRequest) ProtoMessage()               {}
func (*NodesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *NodesRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Pod struct {
	InstanceNo int32  `protobuf:"varint,1,opt,name=InstanceNo" json:"InstanceNo,omitempty"`
	IP         string `protobuf:"bytes,2,opt,name=IP" json:"IP,omitempty"`
	Port       int32  `protobuf:"varint,3,opt,name=Port" json:"Port,omitempty"`
	ProcName   string `protobuf:"bytes,4,opt,name=ProcName" json:"ProcName,omitempty"`
}

func (m *Pod) Reset()                    { *m = Pod{} }
func (m *Pod) String() string            { return proto.CompactTextString(m) }
func (*Pod) ProtoMessage()               {}
func (*Pod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *Pod) GetInstanceNo() int32 {
	if m != nil {
		return m.InstanceNo
	}
	return 0
}

func (m *Pod) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *Pod) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Pod) GetProcName() string {
	if m != nil {
		return m.ProcName
	}
	return ""
}

type PodGroup struct {
	Pods []*Pod `protobuf:"bytes,1,rep,name=Pods" json:"Pods,omitempty"`
}

func (m *PodGroup) Reset()                    { *m = PodGroup{} }
func (m *PodGroup) String() string            { return proto.CompactTextString(m) }
func (*PodGroup) ProtoMessage()               {}
func (*PodGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *PodGroup) GetPods() []*Pod {
	if m != nil {
		return m.Pods
	}
	return nil
}

type PodgroupReply struct {
	Data []*PodGroup `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty"`
}

func (m *PodgroupReply) Reset()                    { *m = PodgroupReply{} }
func (m *PodgroupReply) String() string            { return proto.CompactTextString(m) }
func (*PodgroupReply) ProtoMessage()               {}
func (*PodgroupReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *PodgroupReply) GetData() []*PodGroup {
	if m != nil {
		return m.Data
	}
	return nil
}

type PodgroupRequest struct {
	Appname string `protobuf:"bytes,1,opt,name=Appname" json:"Appname,omitempty"`
}

func (m *PodgroupRequest) Reset()                    { *m = PodgroupRequest{} }
func (m *PodgroupRequest) String() string            { return proto.CompactTextString(m) }
func (*PodgroupRequest) ProtoMessage()               {}
func (*PodgroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *PodgroupRequest) GetAppname() string {
	if m != nil {
		return m.Appname
	}
	return ""
}

type ContainerForProxy struct {
	ContainerIp   string `protobuf:"bytes,1,opt,name=ContainerIp" json:"ContainerIp,omitempty"`
	ContainerPort int32  `protobuf:"varint,2,opt,name=ContainerPort" json:"ContainerPort,omitempty"`
}

func (m *ContainerForProxy) Reset()                    { *m = ContainerForProxy{} }
func (m *ContainerForProxy) String() string            { return proto.CompactTextString(m) }
func (*ContainerForProxy) ProtoMessage()               {}
func (*ContainerForProxy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *ContainerForProxy) GetContainerIp() string {
	if m != nil {
		return m.ContainerIp
	}
	return ""
}

func (m *ContainerForProxy) GetContainerPort() int32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

type ProcInfo struct {
	Containers []*ContainerForProxy `protobuf:"bytes,1,rep,name=Containers" json:"Containers,omitempty"`
}

func (m *ProcInfo) Reset()                    { *m = ProcInfo{} }
func (m *ProcInfo) String() string            { return proto.CompactTextString(m) }
func (*ProcInfo) ProtoMessage()               {}
func (*ProcInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *ProcInfo) GetContainers() []*ContainerForProxy {
	if m != nil {
		return m.Containers
	}
	return nil
}

type ProxyReply struct {
	Data map[string]*ProcInfo `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ProxyReply) Reset()                    { *m = ProxyReply{} }
func (m *ProxyReply) String() string            { return proto.CompactTextString(m) }
func (*ProxyReply) ProtoMessage()               {}
func (*ProxyReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *ProxyReply) GetData() map[string]*ProcInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type ProxyRequest struct {
	Appname string `protobuf:"bytes,1,opt,name=Appname" json:"Appname,omitempty"`
}

func (m *ProxyRequest) Reset()                    { *m = ProxyRequest{} }
func (m *ProxyRequest) String() string            { return proto.CompactTextString(m) }
func (*ProxyRequest) ProtoMessage()               {}
func (*ProxyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *ProxyRequest) GetAppname() string {
	if m != nil {
		return m.Appname
	}
	return ""
}

type PodInfoForRebellion struct {
	Annotation string `protobuf:"bytes,1,opt,name=Annotation" json:"Annotation,omitempty"`
	AppVersion string `protobuf:"bytes,2,opt,name=AppVersion" json:"AppVersion,omitempty"`
	InstanceNo int32  `protobuf:"varint,3,opt,name=InstanceNo" json:"InstanceNo,omitempty"`
}

func (m *PodInfoForRebellion) Reset()                    { *m = PodInfoForRebellion{} }
func (m *PodInfoForRebellion) String() string            { return proto.CompactTextString(m) }
func (*PodInfoForRebellion) ProtoMessage()               {}
func (*PodInfoForRebellion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *PodInfoForRebellion) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}

func (m *PodInfoForRebellion) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *PodInfoForRebellion) GetInstanceNo() int32 {
	if m != nil {
		return m.InstanceNo
	}
	return 0
}

type CoreInfoForRebellion struct {
	PodInfos []*PodInfoForRebellion `protobuf:"bytes,1,rep,name=PodInfos" json:"PodInfos,omitempty"`
}

func (m *CoreInfoForRebellion) Reset()                    { *m = CoreInfoForRebellion{} }
func (m *CoreInfoForRebellion) String() string            { return proto.CompactTextString(m) }
func (*CoreInfoForRebellion) ProtoMessage()               {}
func (*CoreInfoForRebellion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *CoreInfoForRebellion) GetPodInfos() []*PodInfoForRebellion {
	if m != nil {
		return m.PodInfos
	}
	return nil
}

type RebellionLocalprocsReply struct {
	Data map[string]*CoreInfoForRebellion `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RebellionLocalprocsReply) Reset()                    { *m = RebellionLocalprocsReply{} }
func (m *RebellionLocalprocsReply) String() string            { return proto.CompactTextString(m) }
func (*RebellionLocalprocsReply) ProtoMessage()               {}
func (*RebellionLocalprocsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *RebellionLocalprocsReply) GetData() map[string]*CoreInfoForRebellion {
	if m != nil {
		return m.Data
	}
	return nil
}

type RebellionLocalprocsRequest struct {
	Appname string `protobuf:"bytes,1,opt,name=Appname" json:"Appname,omitempty"`
}

func (m *RebellionLocalprocsRequest) Reset()                    { *m = RebellionLocalprocsRequest{} }
func (m *RebellionLocalprocsRequest) String() string            { return proto.CompactTextString(m) }
func (*RebellionLocalprocsRequest) ProtoMessage()               {}
func (*RebellionLocalprocsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *RebellionLocalprocsRequest) GetAppname() string {
	if m != nil {
		return m.Appname
	}
	return ""
}

type StreamrouterPortsRequest struct {
	Appname string `protobuf:"bytes,1,opt,name=Appname" json:"Appname,omitempty"`
}

func (m *StreamrouterPortsRequest) Reset()                    { *m = StreamrouterPortsRequest{} }
func (m *StreamrouterPortsRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamrouterPortsRequest) ProtoMessage()               {}
func (*StreamrouterPortsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *StreamrouterPortsRequest) GetAppname() string {
	if m != nil {
		return m.Appname
	}
	return ""
}

type StreamrouterPortsReply struct {
	Data []int32 `protobuf:"varint,1,rep,packed,name=Data" json:"Data,omitempty"`
}

func (m *StreamrouterPortsReply) Reset()                    { *m = StreamrouterPortsReply{} }
func (m *StreamrouterPortsReply) String() string            { return proto.CompactTextString(m) }
func (*StreamrouterPortsReply) ProtoMessage()               {}
func (*StreamrouterPortsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *StreamrouterPortsReply) GetData() []int32 {
	if m != nil {
		return m.Data
	}
	return nil
}

type StreamUpstream struct {
	Host       string `protobuf:"bytes,1,opt,name=Host" json:"Host,omitempty"`
	InstanceNo int32  `protobuf:"varint,2,opt,name=InstanceNo" json:"InstanceNo,omitempty"`
}

func (m *StreamUpstream) Reset()                    { *m = StreamUpstream{} }
func (m *StreamUpstream) String() string            { return proto.CompactTextString(m) }
func (*StreamUpstream) ProtoMessage()               {}
func (*StreamUpstream) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *StreamUpstream) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *StreamUpstream) GetInstanceNo() int32 {
	if m != nil {
		return m.InstanceNo
	}
	return 0
}

type StreamService struct {
	UpstreamPort int32  `protobuf:"varint,1,opt,name=UpstreamPort" json:"UpstreamPort,omitempty"`
	ListenPort   int32  `protobuf:"varint,2,opt,name=ListenPort" json:"ListenPort,omitempty"`
	Send         string `protobuf:"bytes,3,opt,name=Send" json:"Send,omitempty"`
	Expect       string `protobuf:"bytes,4,opt,name=Expect" json:"Expect,omitempty"`
}

func (m *StreamService) Reset()                    { *m = StreamService{} }
func (m *StreamService) String() string            { return proto.CompactTextString(m) }
func (*StreamService) ProtoMessage()               {}
func (*StreamService) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *StreamService) GetUpstreamPort() int32 {
	if m != nil {
		return m.UpstreamPort
	}
	return 0
}

func (m *StreamService) GetListenPort() int32 {
	if m != nil {
		return m.ListenPort
	}
	return 0
}

func (m *StreamService) GetSend() string {
	if m != nil {
		return m.Send
	}
	return ""
}

func (m *StreamService) GetExpect() string {
	if m != nil {
		return m.Expect
	}
	return ""
}

type StreamProc struct {
	Name      string            `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Upstreams []*StreamUpstream `protobuf:"bytes,2,rep,name=Upstreams" json:"Upstreams,omitempty"`
	Services  []*StreamService  `protobuf:"bytes,3,rep,name=Services" json:"Services,omitempty"`
}

func (m *StreamProc) Reset()                    { *m = StreamProc{} }
func (m *StreamProc) String() string            { return proto.CompactTextString(m) }
func (*StreamProc) ProtoMessage()               {}
func (*StreamProc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *StreamProc) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StreamProc) GetUpstreams() []*StreamUpstream {
	if m != nil {
		return m.Upstreams
	}
	return nil
}

func (m *StreamProc) GetServices() []*StreamService {
	if m != nil {
		return m.Services
	}
	return nil
}

type StreamProcList struct {
	Procs []*StreamProc `protobuf:"bytes,1,rep,name=procs" json:"procs,omitempty"`
}

func (m *StreamProcList) Reset()                    { *m = StreamProcList{} }
func (m *StreamProcList) String() string            { return proto.CompactTextString(m) }
func (*StreamProcList) ProtoMessage()               {}
func (*StreamProcList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *StreamProcList) GetProcs() []*StreamProc {
	if m != nil {
		return m.Procs
	}
	return nil
}

type Port struct {
	Srcport int32  `protobuf:"varint,1,opt,name=Srcport" json:"Srcport,omitempty"`
	Dstport int32  `protobuf:"varint,2,opt,name=Dstport" json:"Dstport,omitempty"`
	Proto   string `protobuf:"bytes,3,opt,name=Proto" json:"Proto,omitempty"`
}

func (m *Port) Reset()                    { *m = Port{} }
func (m *Port) String() string            { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()               {}
func (*Port) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *Port) GetSrcport() int32 {
	if m != nil {
		return m.Srcport
	}
	return 0
}

func (m *Port) GetDstport() int32 {
	if m != nil {
		return m.Dstport
	}
	return 0
}

func (m *Port) GetProto() string {
	if m != nil {
		return m.Proto
	}
	return ""
}

type Annotation struct {
	Ports []*Port `protobuf:"bytes,1,rep,name=Ports" json:"Ports,omitempty"`
}

func (m *Annotation) Reset()                    { *m = Annotation{} }
func (m *Annotation) String() string            { return proto.CompactTextString(m) }
func (*Annotation) ProtoMessage()               {}
func (*Annotation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *Annotation) GetPorts() []*Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

type StreamrouterStreamprocsReply struct {
	Data map[string]*StreamProcList `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *StreamrouterStreamprocsReply) Reset()                    { *m = StreamrouterStreamprocsReply{} }
func (m *StreamrouterStreamprocsReply) String() string            { return proto.CompactTextString(m) }
func (*StreamrouterStreamprocsReply) ProtoMessage()               {}
func (*StreamrouterStreamprocsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

func (m *StreamrouterStreamprocsReply) GetData() map[string]*StreamProcList {
	if m != nil {
		return m.Data
	}
	return nil
}

type StreamrouterStreamprocsRequest struct {
	Appname string `protobuf:"bytes,1,opt,name=Appname" json:"Appname,omitempty"`
}

func (m *StreamrouterStreamprocsRequest) Reset()                    { *m = StreamrouterStreamprocsRequest{} }
func (m *StreamrouterStreamprocsRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamrouterStreamprocsRequest) ProtoMessage()               {}
func (*StreamrouterStreamprocsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *StreamrouterStreamprocsRequest) GetAppname() string {
	if m != nil {
		return m.Appname
	}
	return ""
}

type ContainerForWebrouter struct {
	IP     string `protobuf:"bytes,1,opt,name=IP" json:"IP,omitempty"`
	Expose int32  `protobuf:"varint,2,opt,name=Expose" json:"Expose,omitempty"`
}

func (m *ContainerForWebrouter) Reset()                    { *m = ContainerForWebrouter{} }
func (m *ContainerForWebrouter) String() string            { return proto.CompactTextString(m) }
func (*ContainerForWebrouter) ProtoMessage()               {}
func (*ContainerForWebrouter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{53} }

func (m *ContainerForWebrouter) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *ContainerForWebrouter) GetExpose() int32 {
	if m != nil {
		return m.Expose
	}
	return 0
}

type PodInfoForWebrouter struct {
	Annotation string                   `protobuf:"bytes,1,opt,name=Annotation" json:"Annotation,omitempty"`
	Containers []*ContainerForWebrouter `protobuf:"bytes,2,rep,name=Containers" json:"Containers,omitempty"`
}

func (m *PodInfoForWebrouter) Reset()                    { *m = PodInfoForWebrouter{} }
func (m *PodInfoForWebrouter) String() string            { return proto.CompactTextString(m) }
func (*PodInfoForWebrouter) ProtoMessage()               {}
func (*PodInfoForWebrouter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

func (m *PodInfoForWebrouter) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}

func (m *PodInfoForWebrouter) GetContainers() []*ContainerForWebrouter {
	if m != nil {
		return m.Containers
	}
	return nil
}

type CoreInfoForWebrouter struct {
	PodInfos []*PodInfoForWebrouter `protobuf:"bytes,1,rep,name=PodInfos" json:"PodInfos,omitempty"`
}

func (m *CoreInfoForWebrouter) Reset()                    { *m = CoreInfoForWebrouter{} }
func (m *CoreInfoForWebrouter) String() string            { return proto.CompactTextString(m) }
func (*CoreInfoForWebrouter) ProtoMessage()               {}
func (*CoreInfoForWebrouter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

func (m *CoreInfoForWebrouter) GetPodInfos() []*PodInfoForWebrouter {
	if m != nil {
		return m.PodInfos
	}
	return nil
}

type WebrouterWebprocsReply struct {
	Data map[string]*CoreInfoForWebrouter `protobuf:"bytes,1,rep,name=Data" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *WebrouterWebprocsReply) Reset()                    { *m = WebrouterWebprocsReply{} }
func (m *WebrouterWebprocsReply) String() string            { return proto.CompactTextString(m) }
func (*WebrouterWebprocsReply) ProtoMessage()               {}
func (*WebrouterWebprocsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

func (m *WebrouterWebprocsReply) GetData() map[string]*CoreInfoForWebrouter {
	if m != nil {
		return m.Data
	}
	return nil
}

type WebrouterWebprocsRequest struct {
	Appname string `protobuf:"bytes,1,opt,name=Appname" json:"Appname,omitempty"`
}

func (m *WebrouterWebprocsRequest) Reset()                    { *m = WebrouterWebprocsRequest{} }
func (m *WebrouterWebprocsRequest) String() string            { return proto.CompactTextString(m) }
func (*WebrouterWebprocsRequest) ProtoMessage()               {}
func (*WebrouterWebprocsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

func (m *WebrouterWebprocsRequest) GetAppname() string {
	if m != nil {
		return m.Appname
	}
	return ""
}

type EmptyRequest struct {
}

func (m *EmptyRequest) Reset()                    { *m = EmptyRequest{} }
func (m *EmptyRequest) String() string            { return proto.CompactTextString(m) }
func (*EmptyRequest) ProtoMessage()               {}
func (*EmptyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

type VersionReply struct {
	Version    string `protobuf:"bytes,1,opt,name=Version" json:"Version,omitempty"`
	APIVersion string `protobuf:"bytes,2,opt,name=APIVersion" json:"APIVersion,omitempty"`
}

func (m *VersionReply) Reset()                    { *m = VersionReply{} }
func (m *VersionReply) String() string            { return proto.CompactTextString(m) }
func (*VersionReply) ProtoMessage()               {}
func (*VersionReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{59} }

func (m *VersionReply) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *VersionReply) GetAPIVersion() string {
	if m != nil {
		return m.APIVersion
	}
	return ""
}

type WatcherStatus struct {
	NumReceivers int32  `protobuf:"varint,1,opt,name=NumReceivers" json:"NumReceivers,omitempty"`
	UpdateTime   int64  `protobuf:"varint,2,opt,name=UpdateTime" json:"UpdateTime,omitempty"`
	LastEvent    []byte `protobuf:"bytes,3,opt,name=LastEvent,proto3" json:"LastEvent,omitempty"`
	TotalKeys    int32  `protobuf:"varint,4,opt,name=TotalKeys" json:"TotalKeys,omitempty"`
}

func (m *WatcherStatus) Reset()                    { *m = WatcherStatus{} }
func (m *WatcherStatus) String() string            { return proto.CompactTextString(m) }
func (*WatcherStatus) ProtoMessage()               {}
func (*WatcherStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{60} }

func (m *WatcherStatus) GetNumReceivers() int32 {
	if m != nil {
		return m.NumReceivers
	}
	return 0
}

func (m *WatcherStatus) GetUpdateTime() int64 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

func (m *WatcherStatus) GetLastEvent() []byte {
	if m != nil {
		return m.LastEvent
	}
	return nil
}

func (m *WatcherStatus) GetTotalKeys() int32 {
	if m != nil {
		return m.TotalKeys
	}
	return 0
}

type StatusReply struct {
	Goroutines int32                     `protobuf:"varint,1,opt,name=Goroutines" json:"Goroutines,omitempty"`
	Status     map[string]*WatcherStatus `protobuf:"bytes,2,rep,name=Status" json:"Status,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *StatusReply) Reset()                    { *m = StatusReply{} }
func (m *StatusReply) String() string            { return proto.CompactTextString(m) }
func (*StatusReply) ProtoMessage()               {}
func (*StatusReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{61} }

func (m *StatusReply) GetGoroutines() int32 {
	if m != nil {
		return m.Goroutines
	}
	return 0
}

func (m *StatusReply) GetStatus() map[string]*WatcherStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func init() {
	proto.RegisterType((*AppnameRequest)(nil), "message.AppnameRequest")
	proto.RegisterType((*AppnameReply)(nil), "message.AppnameReply")
	proto.RegisterType((*AppInfo)(nil), "message.AppInfo")
	proto.RegisterType((*AppsReply)(nil), "message.AppsReply")
	proto.RegisterType((*AppsRequest)(nil), "message.AppsRequest")
	proto.RegisterType((*ContainerForBackupctl)(nil), "message.ContainerForBackupctl")
	proto.RegisterType((*PodInfoForBackupctl)(nil), "message.PodInfoForBackupctl")
	proto.RegisterType((*BackupctlReply)(nil), "message.BackupctlReply")
	proto.RegisterType((*BackupctlReply_PodInfoList)(nil), "message.BackupctlReply.PodInfoList")
	proto.RegisterType((*BackupctlRequest)(nil), "message.BackupctlRequest")
	proto.RegisterType((*ConfigRequest)(nil), "message.ConfigRequest")
	proto.RegisterType((*ConfigReply)(nil), "message.ConfigReply")
	proto.RegisterType((*Info)(nil), "message.Info")
	proto.RegisterType((*ContainersReply)(nil), "message.ContainersReply")
	proto.RegisterType((*ContainersRequest)(nil), "message.ContainersRequest")
	proto.RegisterType((*Container)(nil), "message.Container")
	proto.RegisterType((*Dependency)(nil), "message.Dependency")
	proto.RegisterType((*PodInfo)(nil), "message.PodInfo")
	proto.RegisterType((*CoreInfo)(nil), "message.CoreInfo")
	proto.RegisterType((*CoreinfoReply)(nil), "message.CoreinfoReply")
	proto.RegisterType((*CoreinfoRequest)(nil), "message.CoreinfoRequest")
	proto.RegisterType((*ContainerInfo)(nil), "message.ContainerInfo")
	proto.RegisterType((*DependsItem)(nil), "message.DependsItem")
	proto.RegisterType((*DependsAppMap)(nil), "message.DependsAppMap")
	proto.RegisterType((*DependsNodeMap)(nil), "message.DependsNodeMap")
	proto.RegisterType((*DependsReply)(nil), "message.DependsReply")
	proto.RegisterType((*DependsRequest)(nil), "message.DependsRequest")
	proto.RegisterType((*LocalspecReply)(nil), "message.LocalspecReply")
	proto.RegisterType((*LocalspecRequest)(nil), "message.LocalspecRequest")
	proto.RegisterType((*NodeInfo)(nil), "message.NodeInfo")
	proto.RegisterType((*NodeInfo_Value)(nil), "message.NodeInfo.Value")
	proto.RegisterType((*NodesReply)(nil), "message.NodesReply")
	proto.RegisterType((*NodesRequest)(nil), "message.NodesRequest")
	proto.RegisterType((*Pod)(nil), "message.Pod")
	proto.RegisterType((*PodGroup)(nil), "message.PodGroup")
	proto.RegisterType((*PodgroupReply)(nil), "message.PodgroupReply")
	proto.RegisterType((*PodgroupRequest)(nil), "message.PodgroupRequest")
	proto.RegisterType((*ContainerForProxy)(nil), "message.ContainerForProxy")
	proto.RegisterType((*ProcInfo)(nil), "message.ProcInfo")
	proto.RegisterType((*ProxyReply)(nil), "message.ProxyReply")
	proto.RegisterType((*ProxyRequest)(nil), "message.ProxyRequest")
	proto.RegisterType((*PodInfoForRebellion)(nil), "message.PodInfoForRebellion")
	proto.RegisterType((*CoreInfoForRebellion)(nil), "message.CoreInfoForRebellion")
	proto.RegisterType((*RebellionLocalprocsReply)(nil), "message.RebellionLocalprocsReply")
	proto.RegisterType((*RebellionLocalprocsRequest)(nil), "message.RebellionLocalprocsRequest")
	proto.RegisterType((*StreamrouterPortsRequest)(nil), "message.StreamrouterPortsRequest")
	proto.RegisterType((*StreamrouterPortsReply)(nil), "message.StreamrouterPortsReply")
	proto.RegisterType((*StreamUpstream)(nil), "message.StreamUpstream")
	proto.RegisterType((*StreamService)(nil), "message.StreamService")
	proto.RegisterType((*StreamProc)(nil), "message.StreamProc")
	proto.RegisterType((*StreamProcList)(nil), "message.StreamProcList")
	proto.RegisterType((*Port)(nil), "message.Port")
	proto.RegisterType((*Annotation)(nil), "message.Annotation")
	proto.RegisterType((*StreamrouterStreamprocsReply)(nil), "message.StreamrouterStreamprocsReply")
	proto.RegisterType((*StreamrouterStreamprocsRequest)(nil), "message.StreamrouterStreamprocsRequest")
	proto.RegisterType((*ContainerForWebrouter)(nil), "message.ContainerForWebrouter")
	proto.RegisterType((*PodInfoForWebrouter)(nil), "message.PodInfoForWebrouter")
	proto.RegisterType((*CoreInfoForWebrouter)(nil), "message.CoreInfoForWebrouter")
	proto.RegisterType((*WebrouterWebprocsReply)(nil), "message.WebrouterWebprocsReply")
	proto.RegisterType((*WebrouterWebprocsRequest)(nil), "message.WebrouterWebprocsRequest")
	proto.RegisterType((*EmptyRequest)(nil), "message.EmptyRequest")
	proto.RegisterType((*VersionReply)(nil), "message.VersionReply")
	proto.RegisterType((*WatcherStatus)(nil), "message.WatcherStatus")
	proto.RegisterType((*StatusReply)(nil), "message.StatusReply")
	proto.RegisterEnum("message.NodeInfo_Value_Type", NodeInfo_Value_Type_name, NodeInfo_Value_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Appname service

type AppnameClient interface {
	Get(ctx context.Context, in *AppnameRequest, opts ...grpc.CallOption) (*AppnameReply, error)
}

type appnameClient struct {
	cc *grpc.ClientConn
}

func NewAppnameClient(cc *grpc.ClientConn) AppnameClient {
	return &appnameClient{cc}
}

func (c *appnameClient) Get(ctx context.Context, in *AppnameRequest, opts ...grpc.CallOption) (*AppnameReply, error) {
	out := new(AppnameReply)
	err := grpc.Invoke(ctx, "/message.Appname/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Appname service

type AppnameServer interface {
	Get(context.Context, *AppnameRequest) (*AppnameReply, error)
}

func RegisterAppnameServer(s *grpc.Server, srv AppnameServer) {
	s.RegisterService(&_Appname_serviceDesc, srv)
}

func _Appname_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppnameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppnameServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Appname/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppnameServer).Get(ctx, req.(*AppnameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Appname_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.Appname",
	HandlerType: (*AppnameServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Appname_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "message.proto",
}

// Client API for Apps service

type AppsClient interface {
	Get(ctx context.Context, in *AppsRequest, opts ...grpc.CallOption) (*AppsReply, error)
	Watch(ctx context.Context, in *AppsRequest, opts ...grpc.CallOption) (Apps_WatchClient, error)
}

type appsClient struct {
	cc *grpc.ClientConn
}

func NewAppsClient(cc *grpc.ClientConn) AppsClient {
	return &appsClient{cc}
}

func (c *appsClient) Get(ctx context.Context, in *AppsRequest, opts ...grpc.CallOption) (*AppsReply, error) {
	out := new(AppsReply)
	err := grpc.Invoke(ctx, "/message.Apps/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appsClient) Watch(ctx context.Context, in *AppsRequest, opts ...grpc.CallOption) (Apps_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Apps_serviceDesc.Streams[0], c.cc, "/message.Apps/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &appsWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Apps_WatchClient interface {
	Recv() (*AppsReply, error)
	grpc.ClientStream
}

type appsWatchClient struct {
	grpc.ClientStream
}

func (x *appsWatchClient) Recv() (*AppsReply, error) {
	m := new(AppsReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Apps service

type AppsServer interface {
	Get(context.Context, *AppsRequest) (*AppsReply, error)
	Watch(*AppsRequest, Apps_WatchServer) error
}

func RegisterAppsServer(s *grpc.Server, srv AppsServer) {
	s.RegisterService(&_Apps_serviceDesc, srv)
}

func _Apps_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Apps/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppsServer).Get(ctx, req.(*AppsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apps_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AppsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppsServer).Watch(m, &appsWatchServer{stream})
}

type Apps_WatchServer interface {
	Send(*AppsReply) error
	grpc.ServerStream
}

type appsWatchServer struct {
	grpc.ServerStream
}

func (x *appsWatchServer) Send(m *AppsReply) error {
	return x.ServerStream.SendMsg(m)
}

var _Apps_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.Apps",
	HandlerType: (*AppsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Apps_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Apps_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for Backupctl service

type BackupctlClient interface {
	Get(ctx context.Context, in *BackupctlRequest, opts ...grpc.CallOption) (*BackupctlReply, error)
	Watch(ctx context.Context, in *BackupctlRequest, opts ...grpc.CallOption) (Backupctl_WatchClient, error)
}

type backupctlClient struct {
	cc *grpc.ClientConn
}

func NewBackupctlClient(cc *grpc.ClientConn) BackupctlClient {
	return &backupctlClient{cc}
}

func (c *backupctlClient) Get(ctx context.Context, in *BackupctlRequest, opts ...grpc.CallOption) (*BackupctlReply, error) {
	out := new(BackupctlReply)
	err := grpc.Invoke(ctx, "/message.Backupctl/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupctlClient) Watch(ctx context.Context, in *BackupctlRequest, opts ...grpc.CallOption) (Backupctl_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Backupctl_serviceDesc.Streams[0], c.cc, "/message.Backupctl/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &backupctlWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Backupctl_WatchClient interface {
	Recv() (*BackupctlReply, error)
	grpc.ClientStream
}

type backupctlWatchClient struct {
	grpc.ClientStream
}

func (x *backupctlWatchClient) Recv() (*BackupctlReply, error) {
	m := new(BackupctlReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Backupctl service

type BackupctlServer interface {
	Get(context.Context, *BackupctlRequest) (*BackupctlReply, error)
	Watch(*BackupctlRequest, Backupctl_WatchServer) error
}

func RegisterBackupctlServer(s *grpc.Server, srv BackupctlServer) {
	s.RegisterService(&_Backupctl_serviceDesc, srv)
}

func _Backupctl_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupctlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupctlServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Backupctl/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupctlServer).Get(ctx, req.(*BackupctlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backupctl_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BackupctlRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackupctlServer).Watch(m, &backupctlWatchServer{stream})
}

type Backupctl_WatchServer interface {
	Send(*BackupctlReply) error
	grpc.ServerStream
}

type backupctlWatchServer struct {
	grpc.ServerStream
}

func (x *backupctlWatchServer) Send(m *BackupctlReply) error {
	return x.ServerStream.SendMsg(m)
}

var _Backupctl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.Backupctl",
	HandlerType: (*BackupctlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Backupctl_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Backupctl_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for Config service

type ConfigClient interface {
	Get(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (*ConfigReply, error)
	Watch(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (Config_WatchClient, error)
}

type configClient struct {
	cc *grpc.ClientConn
}

func NewConfigClient(cc *grpc.ClientConn) ConfigClient {
	return &configClient{cc}
}

func (c *configClient) Get(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (*ConfigReply, error) {
	out := new(ConfigReply)
	err := grpc.Invoke(ctx, "/message.Config/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configClient) Watch(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (Config_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Config_serviceDesc.Streams[0], c.cc, "/message.Config/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &configWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Config_WatchClient interface {
	Recv() (*ConfigReply, error)
	grpc.ClientStream
}

type configWatchClient struct {
	grpc.ClientStream
}

func (x *configWatchClient) Recv() (*ConfigReply, error) {
	m := new(ConfigReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Config service

type ConfigServer interface {
	Get(context.Context, *ConfigRequest) (*ConfigReply, error)
	Watch(*ConfigRequest, Config_WatchServer) error
}

func RegisterConfigServer(s *grpc.Server, srv ConfigServer) {
	s.RegisterService(&_Config_serviceDesc, srv)
}

func _Config_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Config/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServer).Get(ctx, req.(*ConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Config_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConfigRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConfigServer).Watch(m, &configWatchServer{stream})
}

type Config_WatchServer interface {
	Send(*ConfigReply) error
	grpc.ServerStream
}

type configWatchServer struct {
	grpc.ServerStream
}

func (x *configWatchServer) Send(m *ConfigReply) error {
	return x.ServerStream.SendMsg(m)
}

var _Config_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.Config",
	HandlerType: (*ConfigServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Config_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Config_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for Containers service

type ContainersClient interface {
	Get(ctx context.Context, in *ContainersRequest, opts ...grpc.CallOption) (*ContainersReply, error)
	Watch(ctx context.Context, in *ContainersRequest, opts ...grpc.CallOption) (Containers_WatchClient, error)
}

type containersClient struct {
	cc *grpc.ClientConn
}

func NewContainersClient(cc *grpc.ClientConn) ContainersClient {
	return &containersClient{cc}
}

func (c *containersClient) Get(ctx context.Context, in *ContainersRequest, opts ...grpc.CallOption) (*ContainersReply, error) {
	out := new(ContainersReply)
	err := grpc.Invoke(ctx, "/message.Containers/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containersClient) Watch(ctx context.Context, in *ContainersRequest, opts ...grpc.CallOption) (Containers_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Containers_serviceDesc.Streams[0], c.cc, "/message.Containers/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &containersWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Containers_WatchClient interface {
	Recv() (*ContainersReply, error)
	grpc.ClientStream
}

type containersWatchClient struct {
	grpc.ClientStream
}

func (x *containersWatchClient) Recv() (*ContainersReply, error) {
	m := new(ContainersReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Containers service

type ContainersServer interface {
	Get(context.Context, *ContainersRequest) (*ContainersReply, error)
	Watch(*ContainersRequest, Containers_WatchServer) error
}

func RegisterContainersServer(s *grpc.Server, srv ContainersServer) {
	s.RegisterService(&_Containers_serviceDesc, srv)
}

func _Containers_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainersServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Containers/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainersServer).Get(ctx, req.(*ContainersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Containers_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ContainersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ContainersServer).Watch(m, &containersWatchServer{stream})
}

type Containers_WatchServer interface {
	Send(*ContainersReply) error
	grpc.ServerStream
}

type containersWatchServer struct {
	grpc.ServerStream
}

func (x *containersWatchServer) Send(m *ContainersReply) error {
	return x.ServerStream.SendMsg(m)
}

var _Containers_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.Containers",
	HandlerType: (*ContainersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Containers_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Containers_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for Coreinfo service

type CoreinfoClient interface {
	Get(ctx context.Context, in *CoreinfoRequest, opts ...grpc.CallOption) (*CoreinfoReply, error)
	Watch(ctx context.Context, in *CoreinfoRequest, opts ...grpc.CallOption) (Coreinfo_WatchClient, error)
}

type coreinfoClient struct {
	cc *grpc.ClientConn
}

func NewCoreinfoClient(cc *grpc.ClientConn) CoreinfoClient {
	return &coreinfoClient{cc}
}

func (c *coreinfoClient) Get(ctx context.Context, in *CoreinfoRequest, opts ...grpc.CallOption) (*CoreinfoReply, error) {
	out := new(CoreinfoReply)
	err := grpc.Invoke(ctx, "/message.Coreinfo/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreinfoClient) Watch(ctx context.Context, in *CoreinfoRequest, opts ...grpc.CallOption) (Coreinfo_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Coreinfo_serviceDesc.Streams[0], c.cc, "/message.Coreinfo/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &coreinfoWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Coreinfo_WatchClient interface {
	Recv() (*CoreinfoReply, error)
	grpc.ClientStream
}

type coreinfoWatchClient struct {
	grpc.ClientStream
}

func (x *coreinfoWatchClient) Recv() (*CoreinfoReply, error) {
	m := new(CoreinfoReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Coreinfo service

type CoreinfoServer interface {
	Get(context.Context, *CoreinfoRequest) (*CoreinfoReply, error)
	Watch(*CoreinfoRequest, Coreinfo_WatchServer) error
}

func RegisterCoreinfoServer(s *grpc.Server, srv CoreinfoServer) {
	s.RegisterService(&_Coreinfo_serviceDesc, srv)
}

func _Coreinfo_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoreinfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreinfoServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Coreinfo/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreinfoServer).Get(ctx, req.(*CoreinfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coreinfo_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CoreinfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CoreinfoServer).Watch(m, &coreinfoWatchServer{stream})
}

type Coreinfo_WatchServer interface {
	Send(*CoreinfoReply) error
	grpc.ServerStream
}

type coreinfoWatchServer struct {
	grpc.ServerStream
}

func (x *coreinfoWatchServer) Send(m *CoreinfoReply) error {
	return x.ServerStream.SendMsg(m)
}

var _Coreinfo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.Coreinfo",
	HandlerType: (*CoreinfoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Coreinfo_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Coreinfo_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for Depends service

type DependsClient interface {
	Get(ctx context.Context, in *DependsRequest, opts ...grpc.CallOption) (*DependsReply, error)
	Watch(ctx context.Context, in *DependsRequest, opts ...grpc.CallOption) (Depends_WatchClient, error)
}

type dependsClient struct {
	cc *grpc.ClientConn
}

func NewDependsClient(cc *grpc.ClientConn) DependsClient {
	return &dependsClient{cc}
}

func (c *dependsClient) Get(ctx context.Context, in *DependsRequest, opts ...grpc.CallOption) (*DependsReply, error) {
	out := new(DependsReply)
	err := grpc.Invoke(ctx, "/message.Depends/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependsClient) Watch(ctx context.Context, in *DependsRequest, opts ...grpc.CallOption) (Depends_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Depends_serviceDesc.Streams[0], c.cc, "/message.Depends/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &dependsWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Depends_WatchClient interface {
	Recv() (*DependsReply, error)
	grpc.ClientStream
}

type dependsWatchClient struct {
	grpc.ClientStream
}

func (x *dependsWatchClient) Recv() (*DependsReply, error) {
	m := new(DependsReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Depends service

type DependsServer interface {
	Get(context.Context, *DependsRequest) (*DependsReply, error)
	Watch(*DependsRequest, Depends_WatchServer) error
}

func RegisterDependsServer(s *grpc.Server, srv DependsServer) {
	s.RegisterService(&_Depends_serviceDesc, srv)
}

func _Depends_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DependsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Depends/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependsServer).Get(ctx, req.(*DependsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Depends_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DependsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DependsServer).Watch(m, &dependsWatchServer{stream})
}

type Depends_WatchServer interface {
	Send(*DependsReply) error
	grpc.ServerStream
}

type dependsWatchServer struct {
	grpc.ServerStream
}

func (x *dependsWatchServer) Send(m *DependsReply) error {
	return x.ServerStream.SendMsg(m)
}

var _Depends_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.Depends",
	HandlerType: (*DependsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Depends_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Depends_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for Localspec service

type LocalspecClient interface {
	Get(ctx context.Context, in *LocalspecRequest, opts ...grpc.CallOption) (*LocalspecReply, error)
}

type localspecClient struct {
	cc *grpc.ClientConn
}

func NewLocalspecClient(cc *grpc.ClientConn) LocalspecClient {
	return &localspecClient{cc}
}

func (c *localspecClient) Get(ctx context.Context, in *LocalspecRequest, opts ...grpc.CallOption) (*LocalspecReply, error) {
	out := new(LocalspecReply)
	err := grpc.Invoke(ctx, "/message.Localspec/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Localspec service

type LocalspecServer interface {
	Get(context.Context, *LocalspecRequest) (*LocalspecReply, error)
}

func RegisterLocalspecServer(s *grpc.Server, srv LocalspecServer) {
	s.RegisterService(&_Localspec_serviceDesc, srv)
}

func _Localspec_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocalspecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalspecServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Localspec/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalspecServer).Get(ctx, req.(*LocalspecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Localspec_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.Localspec",
	HandlerType: (*LocalspecServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Localspec_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "message.proto",
}

// Client API for Nodes service

type NodesClient interface {
	Get(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesReply, error)
	Watch(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (Nodes_WatchClient, error)
}

type nodesClient struct {
	cc *grpc.ClientConn
}

func NewNodesClient(cc *grpc.ClientConn) NodesClient {
	return &nodesClient{cc}
}

func (c *nodesClient) Get(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesReply, error) {
	out := new(NodesReply)
	err := grpc.Invoke(ctx, "/message.Nodes/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodesClient) Watch(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (Nodes_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Nodes_serviceDesc.Streams[0], c.cc, "/message.Nodes/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodesWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Nodes_WatchClient interface {
	Recv() (*NodesReply, error)
	grpc.ClientStream
}

type nodesWatchClient struct {
	grpc.ClientStream
}

func (x *nodesWatchClient) Recv() (*NodesReply, error) {
	m := new(NodesReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Nodes service

type NodesServer interface {
	Get(context.Context, *NodesRequest) (*NodesReply, error)
	Watch(*NodesRequest, Nodes_WatchServer) error
}

func RegisterNodesServer(s *grpc.Server, srv NodesServer) {
	s.RegisterService(&_Nodes_serviceDesc, srv)
}

func _Nodes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Nodes/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodesServer).Get(ctx, req.(*NodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nodes_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NodesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodesServer).Watch(m, &nodesWatchServer{stream})
}

type Nodes_WatchServer interface {
	Send(*NodesReply) error
	grpc.ServerStream
}

type nodesWatchServer struct {
	grpc.ServerStream
}

func (x *nodesWatchServer) Send(m *NodesReply) error {
	return x.ServerStream.SendMsg(m)
}

var _Nodes_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.Nodes",
	HandlerType: (*NodesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Nodes_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Nodes_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for Podgroup service

type PodgroupClient interface {
	Get(ctx context.Context, in *PodgroupRequest, opts ...grpc.CallOption) (*PodgroupReply, error)
	Watch(ctx context.Context, in *PodgroupRequest, opts ...grpc.CallOption) (Podgroup_WatchClient, error)
}

type podgroupClient struct {
	cc *grpc.ClientConn
}

func NewPodgroupClient(cc *grpc.ClientConn) PodgroupClient {
	return &podgroupClient{cc}
}

func (c *podgroupClient) Get(ctx context.Context, in *PodgroupRequest, opts ...grpc.CallOption) (*PodgroupReply, error) {
	out := new(PodgroupReply)
	err := grpc.Invoke(ctx, "/message.Podgroup/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *podgroupClient) Watch(ctx context.Context, in *PodgroupRequest, opts ...grpc.CallOption) (Podgroup_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Podgroup_serviceDesc.Streams[0], c.cc, "/message.Podgroup/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &podgroupWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Podgroup_WatchClient interface {
	Recv() (*PodgroupReply, error)
	grpc.ClientStream
}

type podgroupWatchClient struct {
	grpc.ClientStream
}

func (x *podgroupWatchClient) Recv() (*PodgroupReply, error) {
	m := new(PodgroupReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Podgroup service

type PodgroupServer interface {
	Get(context.Context, *PodgroupRequest) (*PodgroupReply, error)
	Watch(*PodgroupRequest, Podgroup_WatchServer) error
}

func RegisterPodgroupServer(s *grpc.Server, srv PodgroupServer) {
	s.RegisterService(&_Podgroup_serviceDesc, srv)
}

func _Podgroup_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PodgroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PodgroupServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Podgroup/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PodgroupServer).Get(ctx, req.(*PodgroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Podgroup_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PodgroupRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PodgroupServer).Watch(m, &podgroupWatchServer{stream})
}

type Podgroup_WatchServer interface {
	Send(*PodgroupReply) error
	grpc.ServerStream
}

type podgroupWatchServer struct {
	grpc.ServerStream
}

func (x *podgroupWatchServer) Send(m *PodgroupReply) error {
	return x.ServerStream.SendMsg(m)
}

var _Podgroup_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.Podgroup",
	HandlerType: (*PodgroupServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Podgroup_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Podgroup_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for Proxy service

type ProxyClient interface {
	Get(ctx context.Context, in *ProxyRequest, opts ...grpc.CallOption) (*ProxyReply, error)
	Watch(ctx context.Context, in *ProxyRequest, opts ...grpc.CallOption) (Proxy_WatchClient, error)
}

type proxyClient struct {
	cc *grpc.ClientConn
}

func NewProxyClient(cc *grpc.ClientConn) ProxyClient {
	return &proxyClient{cc}
}

func (c *proxyClient) Get(ctx context.Context, in *ProxyRequest, opts ...grpc.CallOption) (*ProxyReply, error) {
	out := new(ProxyReply)
	err := grpc.Invoke(ctx, "/message.Proxy/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) Watch(ctx context.Context, in *ProxyRequest, opts ...grpc.CallOption) (Proxy_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Proxy_serviceDesc.Streams[0], c.cc, "/message.Proxy/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &proxyWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Proxy_WatchClient interface {
	Recv() (*ProxyReply, error)
	grpc.ClientStream
}

type proxyWatchClient struct {
	grpc.ClientStream
}

func (x *proxyWatchClient) Recv() (*ProxyReply, error) {
	m := new(ProxyReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Proxy service

type ProxyServer interface {
	Get(context.Context, *ProxyRequest) (*ProxyReply, error)
	Watch(*ProxyRequest, Proxy_WatchServer) error
}

func RegisterProxyServer(s *grpc.Server, srv ProxyServer) {
	s.RegisterService(&_Proxy_serviceDesc, srv)
}

func _Proxy_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Proxy/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).Get(ctx, req.(*ProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProxyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ProxyServer).Watch(m, &proxyWatchServer{stream})
}

type Proxy_WatchServer interface {
	Send(*ProxyReply) error
	grpc.ServerStream
}

type proxyWatchServer struct {
	grpc.ServerStream
}

func (x *proxyWatchServer) Send(m *ProxyReply) error {
	return x.ServerStream.SendMsg(m)
}

var _Proxy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.Proxy",
	HandlerType: (*ProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Proxy_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Proxy_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for RebellionLocalprocs service

type RebellionLocalprocsClient interface {
	Get(ctx context.Context, in *RebellionLocalprocsRequest, opts ...grpc.CallOption) (*RebellionLocalprocsReply, error)
	Watch(ctx context.Context, in *RebellionLocalprocsRequest, opts ...grpc.CallOption) (RebellionLocalprocs_WatchClient, error)
}

type rebellionLocalprocsClient struct {
	cc *grpc.ClientConn
}

func NewRebellionLocalprocsClient(cc *grpc.ClientConn) RebellionLocalprocsClient {
	return &rebellionLocalprocsClient{cc}
}

func (c *rebellionLocalprocsClient) Get(ctx context.Context, in *RebellionLocalprocsRequest, opts ...grpc.CallOption) (*RebellionLocalprocsReply, error) {
	out := new(RebellionLocalprocsReply)
	err := grpc.Invoke(ctx, "/message.RebellionLocalprocs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rebellionLocalprocsClient) Watch(ctx context.Context, in *RebellionLocalprocsRequest, opts ...grpc.CallOption) (RebellionLocalprocs_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RebellionLocalprocs_serviceDesc.Streams[0], c.cc, "/message.RebellionLocalprocs/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &rebellionLocalprocsWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RebellionLocalprocs_WatchClient interface {
	Recv() (*RebellionLocalprocsReply, error)
	grpc.ClientStream
}

type rebellionLocalprocsWatchClient struct {
	grpc.ClientStream
}

func (x *rebellionLocalprocsWatchClient) Recv() (*RebellionLocalprocsReply, error) {
	m := new(RebellionLocalprocsReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for RebellionLocalprocs service

type RebellionLocalprocsServer interface {
	Get(context.Context, *RebellionLocalprocsRequest) (*RebellionLocalprocsReply, error)
	Watch(*RebellionLocalprocsRequest, RebellionLocalprocs_WatchServer) error
}

func RegisterRebellionLocalprocsServer(s *grpc.Server, srv RebellionLocalprocsServer) {
	s.RegisterService(&_RebellionLocalprocs_serviceDesc, srv)
}

func _RebellionLocalprocs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebellionLocalprocsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RebellionLocalprocsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.RebellionLocalprocs/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RebellionLocalprocsServer).Get(ctx, req.(*RebellionLocalprocsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RebellionLocalprocs_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RebellionLocalprocsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RebellionLocalprocsServer).Watch(m, &rebellionLocalprocsWatchServer{stream})
}

type RebellionLocalprocs_WatchServer interface {
	Send(*RebellionLocalprocsReply) error
	grpc.ServerStream
}

type rebellionLocalprocsWatchServer struct {
	grpc.ServerStream
}

func (x *rebellionLocalprocsWatchServer) Send(m *RebellionLocalprocsReply) error {
	return x.ServerStream.SendMsg(m)
}

var _RebellionLocalprocs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.RebellionLocalprocs",
	HandlerType: (*RebellionLocalprocsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RebellionLocalprocs_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _RebellionLocalprocs_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for StreamrouterPorts service

type StreamrouterPortsClient interface {
	Get(ctx context.Context, in *StreamrouterPortsRequest, opts ...grpc.CallOption) (*StreamrouterPortsReply, error)
	Watch(ctx context.Context, in *StreamrouterPortsRequest, opts ...grpc.CallOption) (StreamrouterPorts_WatchClient, error)
}

type streamrouterPortsClient struct {
	cc *grpc.ClientConn
}

func NewStreamrouterPortsClient(cc *grpc.ClientConn) StreamrouterPortsClient {
	return &streamrouterPortsClient{cc}
}

func (c *streamrouterPortsClient) Get(ctx context.Context, in *StreamrouterPortsRequest, opts ...grpc.CallOption) (*StreamrouterPortsReply, error) {
	out := new(StreamrouterPortsReply)
	err := grpc.Invoke(ctx, "/message.StreamrouterPorts/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamrouterPortsClient) Watch(ctx context.Context, in *StreamrouterPortsRequest, opts ...grpc.CallOption) (StreamrouterPorts_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_StreamrouterPorts_serviceDesc.Streams[0], c.cc, "/message.StreamrouterPorts/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamrouterPortsWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamrouterPorts_WatchClient interface {
	Recv() (*StreamrouterPortsReply, error)
	grpc.ClientStream
}

type streamrouterPortsWatchClient struct {
	grpc.ClientStream
}

func (x *streamrouterPortsWatchClient) Recv() (*StreamrouterPortsReply, error) {
	m := new(StreamrouterPortsReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for StreamrouterPorts service

type StreamrouterPortsServer interface {
	Get(context.Context, *StreamrouterPortsRequest) (*StreamrouterPortsReply, error)
	Watch(*StreamrouterPortsRequest, StreamrouterPorts_WatchServer) error
}

func RegisterStreamrouterPortsServer(s *grpc.Server, srv StreamrouterPortsServer) {
	s.RegisterService(&_StreamrouterPorts_serviceDesc, srv)
}

func _StreamrouterPorts_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamrouterPortsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamrouterPortsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.StreamrouterPorts/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamrouterPortsServer).Get(ctx, req.(*StreamrouterPortsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamrouterPorts_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamrouterPortsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamrouterPortsServer).Watch(m, &streamrouterPortsWatchServer{stream})
}

type StreamrouterPorts_WatchServer interface {
	Send(*StreamrouterPortsReply) error
	grpc.ServerStream
}

type streamrouterPortsWatchServer struct {
	grpc.ServerStream
}

func (x *streamrouterPortsWatchServer) Send(m *StreamrouterPortsReply) error {
	return x.ServerStream.SendMsg(m)
}

var _StreamrouterPorts_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.StreamrouterPorts",
	HandlerType: (*StreamrouterPortsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _StreamrouterPorts_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _StreamrouterPorts_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for StreamrouterStreamprocs service

type StreamrouterStreamprocsClient interface {
	Get(ctx context.Context, in *StreamrouterStreamprocsRequest, opts ...grpc.CallOption) (*StreamrouterStreamprocsReply, error)
	Watch(ctx context.Context, in *StreamrouterStreamprocsRequest, opts ...grpc.CallOption) (StreamrouterStreamprocs_WatchClient, error)
}

type streamrouterStreamprocsClient struct {
	cc *grpc.ClientConn
}

func NewStreamrouterStreamprocsClient(cc *grpc.ClientConn) StreamrouterStreamprocsClient {
	return &streamrouterStreamprocsClient{cc}
}

func (c *streamrouterStreamprocsClient) Get(ctx context.Context, in *StreamrouterStreamprocsRequest, opts ...grpc.CallOption) (*StreamrouterStreamprocsReply, error) {
	out := new(StreamrouterStreamprocsReply)
	err := grpc.Invoke(ctx, "/message.StreamrouterStreamprocs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamrouterStreamprocsClient) Watch(ctx context.Context, in *StreamrouterStreamprocsRequest, opts ...grpc.CallOption) (StreamrouterStreamprocs_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_StreamrouterStreamprocs_serviceDesc.Streams[0], c.cc, "/message.StreamrouterStreamprocs/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamrouterStreamprocsWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamrouterStreamprocs_WatchClient interface {
	Recv() (*StreamrouterStreamprocsReply, error)
	grpc.ClientStream
}

type streamrouterStreamprocsWatchClient struct {
	grpc.ClientStream
}

func (x *streamrouterStreamprocsWatchClient) Recv() (*StreamrouterStreamprocsReply, error) {
	m := new(StreamrouterStreamprocsReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for StreamrouterStreamprocs service

type StreamrouterStreamprocsServer interface {
	Get(context.Context, *StreamrouterStreamprocsRequest) (*StreamrouterStreamprocsReply, error)
	Watch(*StreamrouterStreamprocsRequest, StreamrouterStreamprocs_WatchServer) error
}

func RegisterStreamrouterStreamprocsServer(s *grpc.Server, srv StreamrouterStreamprocsServer) {
	s.RegisterService(&_StreamrouterStreamprocs_serviceDesc, srv)
}

func _StreamrouterStreamprocs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamrouterStreamprocsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamrouterStreamprocsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.StreamrouterStreamprocs/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamrouterStreamprocsServer).Get(ctx, req.(*StreamrouterStreamprocsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamrouterStreamprocs_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamrouterStreamprocsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamrouterStreamprocsServer).Watch(m, &streamrouterStreamprocsWatchServer{stream})
}

type StreamrouterStreamprocs_WatchServer interface {
	Send(*StreamrouterStreamprocsReply) error
	grpc.ServerStream
}

type streamrouterStreamprocsWatchServer struct {
	grpc.ServerStream
}

func (x *streamrouterStreamprocsWatchServer) Send(m *StreamrouterStreamprocsReply) error {
	return x.ServerStream.SendMsg(m)
}

var _StreamrouterStreamprocs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.StreamrouterStreamprocs",
	HandlerType: (*StreamrouterStreamprocsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _StreamrouterStreamprocs_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _StreamrouterStreamprocs_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for WebrouterWebprocs service

type WebrouterWebprocsClient interface {
	Get(ctx context.Context, in *WebrouterWebprocsRequest, opts ...grpc.CallOption) (*WebrouterWebprocsReply, error)
	Watch(ctx context.Context, in *WebrouterWebprocsRequest, opts ...grpc.CallOption) (WebrouterWebprocs_WatchClient, error)
}

type webrouterWebprocsClient struct {
	cc *grpc.ClientConn
}

func NewWebrouterWebprocsClient(cc *grpc.ClientConn) WebrouterWebprocsClient {
	return &webrouterWebprocsClient{cc}
}

func (c *webrouterWebprocsClient) Get(ctx context.Context, in *WebrouterWebprocsRequest, opts ...grpc.CallOption) (*WebrouterWebprocsReply, error) {
	out := new(WebrouterWebprocsReply)
	err := grpc.Invoke(ctx, "/message.WebrouterWebprocs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webrouterWebprocsClient) Watch(ctx context.Context, in *WebrouterWebprocsRequest, opts ...grpc.CallOption) (WebrouterWebprocs_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_WebrouterWebprocs_serviceDesc.Streams[0], c.cc, "/message.WebrouterWebprocs/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &webrouterWebprocsWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WebrouterWebprocs_WatchClient interface {
	Recv() (*WebrouterWebprocsReply, error)
	grpc.ClientStream
}

type webrouterWebprocsWatchClient struct {
	grpc.ClientStream
}

func (x *webrouterWebprocsWatchClient) Recv() (*WebrouterWebprocsReply, error) {
	m := new(WebrouterWebprocsReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for WebrouterWebprocs service

type WebrouterWebprocsServer interface {
	Get(context.Context, *WebrouterWebprocsRequest) (*WebrouterWebprocsReply, error)
	Watch(*WebrouterWebprocsRequest, WebrouterWebprocs_WatchServer) error
}

func RegisterWebrouterWebprocsServer(s *grpc.Server, srv WebrouterWebprocsServer) {
	s.RegisterService(&_WebrouterWebprocs_serviceDesc, srv)
}

func _WebrouterWebprocs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebrouterWebprocsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebrouterWebprocsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.WebrouterWebprocs/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebrouterWebprocsServer).Get(ctx, req.(*WebrouterWebprocsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebrouterWebprocs_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WebrouterWebprocsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WebrouterWebprocsServer).Watch(m, &webrouterWebprocsWatchServer{stream})
}

type WebrouterWebprocs_WatchServer interface {
	Send(*WebrouterWebprocsReply) error
	grpc.ServerStream
}

type webrouterWebprocsWatchServer struct {
	grpc.ServerStream
}

func (x *webrouterWebprocsWatchServer) Send(m *WebrouterWebprocsReply) error {
	return x.ServerStream.SendMsg(m)
}

var _WebrouterWebprocs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.WebrouterWebprocs",
	HandlerType: (*WebrouterWebprocsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _WebrouterWebprocs_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _WebrouterWebprocs_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "message.proto",
}

// Client API for Lainlet service

type LainletClient interface {
	Version(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*VersionReply, error)
	Status(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*StatusReply, error)
}

type lainletClient struct {
	cc *grpc.ClientConn
}

func NewLainletClient(cc *grpc.ClientConn) LainletClient {
	return &lainletClient{cc}
}

func (c *lainletClient) Version(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*VersionReply, error) {
	out := new(VersionReply)
	err := grpc.Invoke(ctx, "/message.Lainlet/Version", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lainletClient) Status(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*StatusReply, error) {
	out := new(StatusReply)
	err := grpc.Invoke(ctx, "/message.Lainlet/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Lainlet service

type LainletServer interface {
	Version(context.Context, *EmptyRequest) (*VersionReply, error)
	Status(context.Context, *EmptyRequest) (*StatusReply, error)
}

func RegisterLainletServer(s *grpc.Server, srv LainletServer) {
	s.RegisterService(&_Lainlet_serviceDesc, srv)
}

func _Lainlet_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LainletServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Lainlet/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LainletServer).Version(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lainlet_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LainletServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/message.Lainlet/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LainletServer).Status(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Lainlet_serviceDesc = grpc.ServiceDesc{
	ServiceName: "message.Lainlet",
	HandlerType: (*LainletServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Lainlet_Version_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _Lainlet_Status_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "message.proto",
}

func init() { proto.RegisterFile("message.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2355 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x5a, 0x4b, 0x6f, 0x1b, 0xc9,
	0xf1, 0x67, 0xf3, 0x21, 0x99, 0x25, 0x52, 0x7f, 0xb9, 0x2d, 0xcb, 0xf3, 0x67, 0xbc, 0x5e, 0xb9,
	0x9d, 0x5d, 0x7b, 0xbd, 0x8e, 0x96, 0xa6, 0xdf, 0x36, 0xbc, 0x86, 0x2c, 0xbf, 0x98, 0xb5, 0xb4,
	0x93, 0x91, 0x56, 0x3e, 0x6c, 0x2e, 0x63, 0xb2, 0x57, 0x21, 0x4c, 0xce, 0x74, 0x66, 0x86, 0x82,
	0xb9, 0x48, 0xb0, 0x97, 0x1c, 0x12, 0x04, 0x48, 0x10, 0x20, 0x7b, 0xcb, 0x77, 0x08, 0x82, 0x20,
	0x39, 0x24, 0x1f, 0x22, 0x97, 0x1c, 0x73, 0xc8, 0x29, 0xdf, 0x22, 0x40, 0xd0, 0x8f, 0x99, 0xe9,
	0x9e, 0x19, 0x92, 0x92, 0xa3, 0x9c, 0x3c, 0xdd, 0xac, 0xaa, 0xfe, 0xd5, 0xb3, 0xab, 0x5a, 0x86,
	0xe6, 0x88, 0x86, 0xa1, 0x7b, 0x40, 0x37, 0x58, 0xe0, 0x47, 0x3e, 0x5e, 0x54, 0x4b, 0xb2, 0x0e,
	0xcb, 0x9b, 0x8c, 0x79, 0xee, 0x88, 0x3a, 0xf4, 0xc7, 0x63, 0x1a, 0x46, 0x78, 0x19, 0xca, 0x03,
	0x66, 0xa1, 0x75, 0x74, 0xa5, 0xee, 0x94, 0x07, 0x8c, 0xfc, 0x04, 0x1a, 0x09, 0x05, 0x1b, 0x4e,
	0xf0, 0x0d, 0xa8, 0x3e, 0x71, 0x23, 0xd7, 0x42, 0xeb, 0x95, 0x2b, 0x4b, 0x9d, 0xf7, 0x37, 0x62,
	0xc1, 0x3a, 0xd1, 0x06, 0xa7, 0x78, 0xea, 0x45, 0xc1, 0xc4, 0x11, 0xc4, 0xad, 0x3b, 0x50, 0x4f,
	0xb6, 0xf0, 0x0a, 0x54, 0xde, 0xd0, 0x89, 0x3a, 0x82, 0x7f, 0xe2, 0x55, 0xa8, 0x1d, 0xba, 0xc3,
	0x31, 0xb5, 0xca, 0x62, 0x4f, 0x2e, 0xee, 0x97, 0xef, 0x22, 0x72, 0x09, 0x16, 0x37, 0x19, 0xeb,
	0x7a, 0x5f, 0xf9, 0xd8, 0x12, 0x9f, 0xfc, 0x0c, 0xc5, 0x1a, 0x2f, 0xc9, 0xcf, 0x11, 0xd4, 0x37,
	0x19, 0x0b, 0x25, 0xc0, 0xb6, 0x01, 0xf0, 0xbc, 0x0e, 0x30, 0x2c, 0x46, 0xd7, 0x9d, 0x8d, 0xee,
	0x43, 0x1d, 0xdd, 0x52, 0x67, 0x45, 0x97, 0xc8, 0x91, 0xe9, 0x78, 0x9b, 0xb0, 0x24, 0xcf, 0x11,
	0xc6, 0x24, 0x6f, 0xe0, 0xec, 0x96, 0xef, 0x45, 0xee, 0xc0, 0xa3, 0xc1, 0x33, 0x3f, 0x78, 0xec,
	0xf6, 0xde, 0x8c, 0x59, 0x2f, 0x1a, 0x72, 0x2b, 0x77, 0xfb, 0xb1, 0x95, 0xbb, 0x7d, 0xb1, 0x66,
	0x4a, 0xfd, 0x72, 0x97, 0xe1, 0x35, 0x58, 0xd8, 0xf1, 0xfb, 0xb4, 0xcb, 0xac, 0x8a, 0xd8, 0x53,
	0x2b, 0xdc, 0x82, 0x53, 0xfc, 0x6b, 0x87, 0x5b, 0xa1, 0x2a, 0x7e, 0x49, 0xd6, 0xe4, 0x5b, 0x04,
	0x67, 0x6c, 0xbf, 0xcf, 0x21, 0x19, 0x67, 0x5d, 0x00, 0xd8, 0xf4, 0x3c, 0x3f, 0x72, 0xa3, 0x81,
	0xef, 0xa9, 0x33, 0xb5, 0x1d, 0xfc, 0x29, 0x40, 0x02, 0x32, 0xb4, 0xca, 0xc2, 0x6c, 0x17, 0x12,
	0x25, 0x0b, 0xf1, 0x3b, 0x1a, 0x07, 0x97, 0xdf, 0xf5, 0xc2, 0xc8, 0xf5, 0x7a, 0x74, 0xc7, 0x17,
	0x78, 0x6b, 0x8e, 0xb6, 0x43, 0xfe, 0x85, 0x60, 0x39, 0xe5, 0x14, 0x3e, 0xba, 0x65, 0xf8, 0xe8,
	0x62, 0x72, 0x98, 0x49, 0x96, 0x73, 0xd4, 0x23, 0x58, 0x52, 0x0a, 0xbe, 0x1c, 0x84, 0x11, 0xf7,
	0x34, 0xf3, 0xfb, 0x61, 0xce, 0xd3, 0x05, 0x46, 0x70, 0x04, 0x65, 0xeb, 0x87, 0xb3, 0x3d, 0x7d,
	0xcf, 0xf4, 0xf4, 0xa5, 0x69, 0xb8, 0x34, 0x10, 0xba, 0xf3, 0xaf, 0xc1, 0x8a, 0x46, 0x28, 0xd3,
	0x69, 0x7a, 0xd4, 0x5e, 0x86, 0xe6, 0x96, 0xef, 0x7d, 0x35, 0x38, 0x88, 0x49, 0xd7, 0x60, 0x61,
	0xcf, 0x0d, 0x0e, 0x68, 0xa4, 0x28, 0xd5, 0x8a, 0x7c, 0x0d, 0x4b, 0x31, 0x21, 0xb7, 0x5d, 0xc7,
	0xb0, 0x9d, 0xe1, 0xa8, 0x98, 0xe6, 0xe4, 0xf2, 0xef, 0xef, 0x08, 0xaa, 0x5a, 0xf6, 0xed, 0x98,
	0x7a, 0xf0, 0xa5, 0x08, 0x2f, 0xc6, 0xf6, 0x69, 0x10, 0xf2, 0xf0, 0x2a, 0xab, 0xf0, 0x4a, 0x76,
	0x78, 0xc8, 0xda, 0x81, 0xdf, 0x13, 0xac, 0x32, 0x98, 0x93, 0xf5, 0xac, 0x70, 0x4e, 0x52, 0xc0,
	0xb6, 0x6a, 0x5a, 0x0a, 0xd8, 0x22, 0x55, 0x6c, 0x6b, 0x41, 0xa5, 0x8a, 0x8d, 0x31, 0x54, 0x6d,
	0x3f, 0x88, 0xac, 0x45, 0x11, 0x78, 0xe2, 0x3b, 0x13, 0x92, 0xa7, 0x72, 0x21, 0xf9, 0x1b, 0x04,
	0xff, 0x97, 0x46, 0xb0, 0xb4, 0xeb, 0x6d, 0xc3, 0xae, 0x24, 0x9f, 0x00, 0x53, 0xaa, 0xc7, 0xb3,
	0xd9, 0xb6, 0xbd, 0x64, 0xc6, 0x54, 0x33, 0x91, 0x9b, 0x2d, 0x1d, 0x9f, 0xc0, 0x69, 0xfd, 0x28,
	0x19, 0x13, 0xca, 0x40, 0x5a, 0xfc, 0x24, 0x6b, 0xf2, 0x6f, 0x04, 0xf5, 0x84, 0x83, 0x3b, 0x68,
	0xcb, 0x1f, 0x8d, 0x5c, 0xaf, 0x2f, 0x34, 0xa8, 0x3b, 0xf1, 0x52, 0xd5, 0x9a, 0x72, 0xa6, 0xd6,
	0x54, 0x92, 0x5a, 0xb3, 0x02, 0x95, 0x2d, 0x36, 0x16, 0xf6, 0xaf, 0x39, 0xfc, 0x93, 0xef, 0x3c,
	0xf5, 0x0e, 0xad, 0x9a, 0x90, 0xc3, 0x3f, 0xb9, 0x33, 0x9e, 0xbe, 0x65, 0x7e, 0x48, 0x85, 0xe1,
	0x6b, 0x8e, 0x5a, 0xf1, 0xc8, 0xe9, 0x8e, 0xdc, 0x03, 0x2a, 0xac, 0x5f, 0x77, 0xe4, 0x82, 0x53,
	0x6f, 0xd3, 0x91, 0x1f, 0x4c, 0x84, 0xe9, 0x2b, 0x8e, 0x5a, 0x69, 0x55, 0xad, 0x3e, 0xb5, 0xaa,
	0x41, 0x26, 0x0c, 0x2c, 0x58, 0xdc, 0xf7, 0x87, 0xe3, 0x11, 0x0d, 0xad, 0x25, 0xa9, 0x97, 0x5a,
	0x92, 0x4f, 0x01, 0x9e, 0x50, 0x46, 0xbd, 0x3e, 0xf5, 0x7a, 0x13, 0x4e, 0x67, 0xfb, 0x7d, 0x3d,
	0x40, 0xd5, 0x92, 0x9f, 0x6a, 0xfb, 0xc3, 0x41, 0x6f, 0x22, 0x6c, 0x50, 0x73, 0xd4, 0x8a, 0xfc,
	0x19, 0x09, 0x16, 0x11, 0xde, 0xf3, 0x6a, 0x64, 0xa7, 0xa0, 0x46, 0xe2, 0x7c, 0x88, 0x18, 0x75,
	0xf1, 0x0e, 0x34, 0x12, 0x7c, 0x03, 0x1a, 0x5a, 0x15, 0xc1, 0x75, 0x26, 0xe1, 0x4a, 0xc1, 0x3b,
	0x06, 0x61, 0x26, 0x7a, 0xab, 0xb9, 0xe8, 0xbd, 0x0b, 0xa7, 0xb6, 0xfc, 0x80, 0x0a, 0xe0, 0xd7,
	0xe0, 0x94, 0xd2, 0x21, 0xae, 0x83, 0x2b, 0xd9, 0x3a, 0xe8, 0x24, 0x14, 0x3c, 0xee, 0x9b, 0x9c,
	0x75, 0xc0, 0xb7, 0x45, 0xd4, 0xdf, 0x34, 0xa2, 0x7e, 0x5d, 0x53, 0x49, 0xa3, 0xca, 0xc5, 0xfc,
	0xf7, 0x67, 0xc7, 0xfc, 0x65, 0x33, 0xe6, 0x4f, 0x1b, 0x52, 0xb3, 0x71, 0xff, 0x31, 0x4f, 0xc5,
	0xf8, 0xb0, 0x79, 0x45, 0x73, 0x24, 0x8a, 0xa6, 0xb4, 0xb0, 0xd0, 0x7f, 0x5d, 0x14, 0x47, 0xb5,
	0xf1, 0x44, 0x91, 0xeb, 0x5b, 0x5a, 0x1d, 0x29, 0x17, 0xd4, 0x91, 0x4a, 0xae, 0x8e, 0x54, 0xd3,
	0x3a, 0x42, 0x28, 0x2c, 0x49, 0xcf, 0x84, 0xdd, 0x88, 0x8e, 0xe6, 0x46, 0xc9, 0xed, 0x82, 0x28,
	0x59, 0xcb, 0x47, 0x89, 0xb0, 0x80, 0x46, 0x49, 0x7e, 0x8b, 0xa0, 0xa9, 0xce, 0xd9, 0x64, 0x6c,
	0xdb, 0x65, 0xdc, 0x2d, 0x2e, 0x63, 0x61, 0xce, 0x2d, 0x06, 0x95, 0x68, 0x69, 0x94, 0x5b, 0x38,
	0x75, 0x6b, 0x5b, 0xf6, 0x41, 0xd3, 0xdc, 0x72, 0xd5, 0x74, 0xcb, 0x6a, 0x56, 0x2a, 0xd7, 0x51,
	0xf7, 0xcc, 0xef, 0x10, 0x2c, 0xab, 0x9f, 0xb8, 0xcd, 0x38, 0xae, 0xbb, 0x50, 0xf3, 0xfc, 0x3e,
	0x0d, 0x73, 0x55, 0xd2, 0xa4, 0xdb, 0xe0, 0xff, 0x2a, 0x68, 0x92, 0xa1, 0x65, 0x03, 0xa4, 0x9b,
	0x05, 0xe0, 0xae, 0x99, 0xe0, 0xd6, 0x8a, 0x55, 0xd6, 0xe1, 0x7d, 0x8b, 0xe2, 0x04, 0x0b, 0x67,
	0xb7, 0xa6, 0x3a, 0x51, 0x2e, 0x94, 0xed, 0xd9, 0xa1, 0xfc, 0x3d, 0x13, 0xd6, 0xb9, 0x29, 0x0a,
	0xeb, 0xb8, 0xae, 0x24, 0x56, 0x9b, 0x77, 0xb3, 0xef, 0xc0, 0xf2, 0x4b, 0xbf, 0xe7, 0x0e, 0x43,
	0x46, 0x7b, 0x52, 0x05, 0xac, 0xa9, 0x50, 0x97, 0x08, 0x79, 0x36, 0x08, 0xaa, 0x24, 0x82, 0xe3,
	0xa5, 0xea, 0xd5, 0x2b, 0x49, 0xaf, 0x7e, 0x15, 0x56, 0x34, 0x79, 0xc9, 0xd9, 0x1c, 0x63, 0xd2,
	0xd3, 0xab, 0x15, 0xf9, 0x67, 0x59, 0x16, 0x5d, 0x91, 0x45, 0x1f, 0x02, 0x3a, 0x54, 0x66, 0xb3,
	0x12, 0x0d, 0xe3, 0x5f, 0x37, 0xf6, 0xa5, 0xbd, 0xd0, 0x61, 0xeb, 0x1f, 0x08, 0x6a, 0xfb, 0x5c,
	0x51, 0xdc, 0x81, 0xda, 0x7e, 0x34, 0x61, 0x32, 0x41, 0x97, 0xb5, 0xe6, 0x2b, 0xe5, 0xe2, 0x74,
	0x1b, 0x7b, 0x13, 0x46, 0x1d, 0x49, 0xca, 0x95, 0x0b, 0x0f, 0xdd, 0xa1, 0xd2, 0x42, 0x7c, 0xf3,
	0x4e, 0x70, 0xc4, 0xf7, 0x2a, 0x99, 0x4e, 0x30, 0x23, 0x66, 0xfb, 0xd0, 0x1d, 0x2a, 0xaf, 0x71,
	0x72, 0xde, 0xd0, 0x24, 0x5b, 0xc7, 0x6a, 0x68, 0xbe, 0x03, 0x55, 0x0e, 0x09, 0x03, 0x2c, 0xec,
	0xee, 0x39, 0xdd, 0x9d, 0xe7, 0x2b, 0x25, 0xbc, 0x08, 0x95, 0xed, 0x4d, 0x7b, 0x05, 0xb5, 0xb6,
	0x61, 0x61, 0xff, 0xd8, 0x81, 0x60, 0x22, 0xd5, 0xcf, 0xfa, 0x25, 0x52, 0x31, 0x2f, 0x7d, 0x7b,
	0xdd, 0x08, 0xcf, 0xf7, 0x0c, 0x01, 0xe1, 0xc9, 0xd6, 0xd9, 0x18, 0x93, 0x8e, 0x86, 0x40, 0x43,
	0x9d, 0x24, 0x03, 0x03, 0x43, 0x55, 0xbb, 0x2d, 0xc5, 0x37, 0xa1, 0x50, 0xb1, 0xfd, 0x7e, 0xe6,
	0x02, 0x42, 0xd9, 0x0b, 0x48, 0x95, 0xce, 0x72, 0xae, 0x74, 0x56, 0xb4, 0x16, 0x4c, 0x6f, 0xfb,
	0xaa, 0x66, 0xdb, 0x47, 0xe4, 0xa5, 0xf5, 0x3c, 0xf0, 0xc7, 0x0c, 0xaf, 0x73, 0xde, 0xa4, 0x89,
	0x6f, 0xe8, 0x97, 0x97, 0x23, 0x7e, 0x21, 0xb7, 0xa1, 0x69, 0xfb, 0xfd, 0x03, 0x4e, 0x2d, 0x0d,
	0xf9, 0x81, 0x61, 0xc8, 0xd3, 0x3a, 0x8b, 0x90, 0x29, 0x8d, 0xc7, 0x2f, 0x96, 0x94, 0x6f, 0xde,
	0xc5, 0xf2, 0xa5, 0xd6, 0x7d, 0x3d, 0xf3, 0x03, 0x3b, 0xf0, 0xdf, 0x4e, 0xcc, 0xcb, 0x85, 0xe5,
	0x2f, 0x17, 0x86, 0xbf, 0xab, 0xdd, 0x47, 0xc2, 0x04, 0xb2, 0xc5, 0x30, 0x37, 0xc9, 0x33, 0x69,
	0x0b, 0x91, 0x6a, 0xf7, 0x8d, 0x3b, 0x42, 0xaa, 0xd0, 0x2a, 0x9c, 0xb6, 0x04, 0x06, 0xe3, 0x9e,
	0xe0, 0x01, 0x25, 0x77, 0x67, 0x06, 0x54, 0x4a, 0x72, 0x62, 0x01, 0x15, 0xc3, 0x37, 0xeb, 0x5c,
	0x43, 0x9d, 0x34, 0xcf, 0xb8, 0x63, 0x7d, 0x30, 0x75, 0xe8, 0x6b, 0x3a, 0x1c, 0xf2, 0xeb, 0x72,
	0xde, 0x75, 0x3a, 0x6f, 0xb2, 0x98, 0x37, 0x78, 0xda, 0xb0, 0x1a, 0x37, 0x1c, 0xc6, 0xb9, 0x77,
	0x73, 0x3d, 0x53, 0xd1, 0xec, 0x98, 0xd0, 0x6b, 0xfd, 0xd3, 0x1f, 0x11, 0x58, 0xc9, 0xbe, 0x28,
	0xb5, 0x2c, 0xf0, 0x7b, 0x2a, 0xbf, 0x1f, 0x19, 0xee, 0xf8, 0x38, 0x11, 0x39, 0x8d, 0x21, 0xe7,
	0x9c, 0xfd, 0xd9, 0xce, 0xb9, 0x61, 0x3a, 0xe7, 0xbd, 0x5c, 0x57, 0x65, 0x80, 0xd6, 0x1c, 0x75,
	0x1b, 0x5a, 0x85, 0x18, 0xe6, 0xb9, 0xed, 0x26, 0x58, 0xbb, 0x51, 0x40, 0xdd, 0x51, 0xe0, 0x8f,
	0x23, 0x19, 0xca, 0x47, 0xe0, 0xba, 0x06, 0x6b, 0x05, 0x5c, 0xd9, 0xcb, 0xad, 0xa6, 0x92, 0xf4,
	0x09, 0x2c, 0x4b, 0xea, 0x2f, 0x58, 0x28, 0xfe, 0xe5, 0x54, 0x2f, 0xfc, 0x30, 0xbe, 0x2a, 0xc5,
	0x77, 0xc6, 0xd3, 0xe5, 0x9c, 0xa7, 0xbf, 0x81, 0xa6, 0x94, 0xb2, 0x4b, 0x83, 0xc3, 0x41, 0x8f,
	0x62, 0x02, 0x8d, 0x58, 0xa0, 0x48, 0x4b, 0x59, 0xc3, 0x8c, 0x3d, 0x2e, 0x94, 0x4f, 0xf0, 0xd4,
	0xd3, 0x12, 0x57, 0xdb, 0xe1, 0x40, 0x76, 0xa9, 0xd7, 0x57, 0xf7, 0xab, 0xf8, 0x56, 0x73, 0x10,
	0xed, 0x45, 0xaa, 0xa6, 0xa9, 0x95, 0xc8, 0x4c, 0x89, 0x80, 0x67, 0x4a, 0x51, 0x6d, 0xc5, 0xb7,
	0xa0, 0x1e, 0x1f, 0x1f, 0xf7, 0x86, 0xe9, 0x25, 0x62, 0xda, 0xc0, 0x49, 0x29, 0x71, 0x07, 0x4e,
	0x29, 0xa5, 0xe2, 0x09, 0x62, 0x2d, 0xc3, 0xa5, 0x7e, 0x76, 0x12, 0x3a, 0xf2, 0x20, 0x36, 0x2a,
	0x07, 0x23, 0x9e, 0x4a, 0x3e, 0x82, 0x9a, 0x70, 0xba, 0x0a, 0xce, 0x33, 0x19, 0x11, 0x9c, 0xce,
	0x91, 0x14, 0xc4, 0x96, 0xc5, 0x9c, 0x7b, 0x78, 0x37, 0xe8, 0xb1, 0xd4, 0x7a, 0xf1, 0x92, 0xff,
	0xf2, 0x24, 0x8c, 0x58, 0x6a, 0xb5, 0x78, 0xc9, 0xef, 0x5d, 0x3b, 0xf0, 0x23, 0x5f, 0xd9, 0x4c,
	0x2e, 0xc8, 0x75, 0x3d, 0xcf, 0xf9, 0x40, 0x2c, 0x62, 0x42, 0x41, 0x69, 0x6a, 0xa9, 0x17, 0x44,
	0x8e, 0xfc, 0x8d, 0xfc, 0x09, 0xc1, 0x79, 0x3d, 0x8a, 0xe4, 0xb7, 0x96, 0x6c, 0x5b, 0x46, 0xb2,
	0x7d, 0x92, 0xd1, 0xa7, 0x98, 0xe9, 0xc4, 0x7a, 0x3f, 0xd3, 0xb8, 0x7a, 0xaa, 0xdd, 0x87, 0x0b,
	0x53, 0x11, 0xcc, 0x4b, 0x9c, 0x47, 0xe6, 0x63, 0xe1, 0x2b, 0xfa, 0x5a, 0x0a, 0x51, 0xd7, 0x2d,
	0x4a, 0xae, 0xdb, 0x74, 0x18, 0x2f, 0xeb, 0xc3, 0xb8, 0x59, 0x66, 0x53, 0xf6, 0x93, 0x7b, 0xff,
	0x4b, 0x64, 0x1a, 0xb7, 0x92, 0x59, 0x66, 0xd3, 0x73, 0x8f, 0x56, 0x66, 0x53, 0x99, 0x69, 0x99,
	0xfd, 0x3d, 0x82, 0xb5, 0x64, 0xff, 0x15, 0x7d, 0xad, 0xf9, 0xfd, 0xa1, 0xe1, 0xf7, 0x8f, 0x12,
	0x81, 0xc5, 0xe4, 0xff, 0x8b, 0x12, 0x9b, 0x02, 0xd6, 0xfc, 0x7e, 0x13, 0xac, 0x02, 0x04, 0xf3,
	0x3c, 0xbe, 0x0c, 0x8d, 0xa7, 0x23, 0x16, 0xc5, 0x37, 0x28, 0x79, 0x01, 0x0d, 0x75, 0xb7, 0x49,
	0x65, 0x2d, 0x58, 0x8c, 0x6f, 0x3f, 0xc5, 0xa9, 0x5d, 0x7d, 0x9b, 0x76, 0x37, 0x7b, 0x35, 0x26,
	0x3b, 0xe4, 0xd7, 0x08, 0x9a, 0xaf, 0xdc, 0xa8, 0xf7, 0x23, 0x1e, 0x83, 0x6e, 0x34, 0x0e, 0x79,
	0x45, 0xdc, 0x19, 0x8f, 0x1c, 0xda, 0xa3, 0x83, 0x43, 0xd9, 0x79, 0x88, 0x8a, 0xa8, 0xef, 0x71,
	0xa9, 0x5f, 0xb0, 0xbe, 0x1b, 0xd1, 0xbd, 0xc1, 0x48, 0xda, 0xa0, 0xe2, 0x68, 0x3b, 0xf8, 0x3c,
	0xd4, 0x5f, 0xba, 0x61, 0xf4, 0xf4, 0x90, 0x7a, 0xb2, 0xd9, 0x6b, 0x38, 0xe9, 0x06, 0xff, 0x75,
	0xcf, 0x8f, 0xdc, 0xe1, 0x67, 0x74, 0x12, 0xaa, 0x29, 0x3a, 0xdd, 0x20, 0x7f, 0x41, 0xb0, 0x24,
	0xa1, 0x48, 0xdd, 0x2e, 0x00, 0x3c, 0xf7, 0xb9, 0xc1, 0x06, 0x1e, 0x8d, 0xd1, 0x68, 0x3b, 0xf8,
	0x2e, 0x2c, 0x48, 0x72, 0x15, 0x91, 0xeb, 0x5a, 0xf6, 0x25, 0x52, 0xd4, 0xb7, 0xf4, 0xb0, 0xa2,
	0x6f, 0xfd, 0x20, 0x3e, 0xe8, 0xd8, 0xa3, 0xa6, 0x61, 0x31, 0xcd, 0xbd, 0x9d, 0xc7, 0x89, 0x0b,
	0xf1, 0x1d, 0xa8, 0x3c, 0xa7, 0x11, 0x3e, 0x97, 0xff, 0xc3, 0x87, 0xf0, 0x61, 0xeb, 0x6c, 0xe1,
	0x5f, 0x44, 0x48, 0xa9, 0xc3, 0xa0, 0xca, 0x87, 0x73, 0x7c, 0x5d, 0x0a, 0x58, 0xcd, 0xfc, 0x61,
	0x42, 0x72, 0xe3, 0xfc, 0x9f, 0x2b, 0x48, 0x09, 0xdf, 0x82, 0x9a, 0x80, 0x76, 0x1c, 0xa6, 0x36,
	0xea, 0xfc, 0x02, 0x41, 0x3d, 0xfd, 0x33, 0xc0, 0x03, 0x79, 0xee, 0xff, 0x17, 0x3d, 0x6a, 0x4b,
	0x39, 0xe7, 0xa6, 0xbc, 0x77, 0x93, 0x12, 0x7e, 0x14, 0x23, 0x78, 0x27, 0xf6, 0x36, 0xea, 0x7c,
	0x0d, 0x0b, 0xf2, 0x81, 0x1a, 0xdf, 0x92, 0x38, 0xd6, 0x72, 0x0f, 0xd7, 0x52, 0xca, 0x6a, 0xd1,
	0x83, 0x36, 0x29, 0xe1, 0x7b, 0x31, 0x82, 0x63, 0x32, 0xb6, 0x51, 0xe7, 0x57, 0x48, 0xaf, 0x70,
	0xf8, 0xa1, 0x04, 0xd0, 0x2a, 0x7c, 0xe1, 0x95, 0xb2, 0xac, 0x69, 0xaf, 0xbf, 0xa4, 0x84, 0x37,
	0x63, 0x20, 0xef, 0x28, 0xa0, 0x8d, 0x3a, 0x3f, 0x43, 0xf2, 0x05, 0x6f, 0xc0, 0x07, 0x82, 0x7b,
	0x12, 0x8e, 0x55, 0xf0, 0xf4, 0x26, 0x65, 0xad, 0x15, 0x3f, 0xca, 0x91, 0x12, 0x7e, 0x18, 0x43,
	0x79, 0x07, 0xe6, 0x36, 0xea, 0x7c, 0x03, 0x8b, 0xea, 0xa1, 0x22, 0x1f, 0xd5, 0xe6, 0x0b, 0x86,
	0x16, 0xd5, 0xfa, 0x63, 0x0a, 0x29, 0xe1, 0x07, 0x31, 0x84, 0x63, 0xb3, 0xb6, 0x51, 0xe7, 0x05,
	0xd4, 0x93, 0xf7, 0x8a, 0x7c, 0x7c, 0x66, 0x9f, 0x32, 0xb4, 0x00, 0x33, 0x5f, 0x4d, 0x48, 0xa9,
	0x33, 0x86, 0x9a, 0x18, 0x6e, 0xf1, 0x0d, 0x29, 0xe5, 0x6c, 0x76, 0xba, 0x96, 0x12, 0xce, 0x14,
	0x0c, 0xdd, 0xa4, 0x84, 0xef, 0xc4, 0x4a, 0x1c, 0x8b, 0x4d, 0x39, 0x32, 0x9e, 0x31, 0xf3, 0x8e,
	0xcc, 0x4c, 0x9f, 0x9a, 0x2f, 0x8c, 0x79, 0xb6, 0xd8, 0x91, 0x47, 0x66, 0x6e, 0x23, 0xae, 0xbd,
	0x1c, 0x58, 0x73, 0xda, 0xeb, 0x03, 0x9a, 0xa6, 0x46, 0x3a, 0x21, 0x16, 0x6b, 0x7f, 0x04, 0xb6,
	0x36, 0xea, 0xfc, 0x15, 0xc1, 0x99, 0x82, 0xc1, 0x02, 0x7f, 0x2e, 0x51, 0x5c, 0x9a, 0x3d, 0x01,
	0x49, 0xe1, 0x17, 0xe7, 0x8e, 0x49, 0xa4, 0x84, 0x77, 0x63, 0x84, 0x27, 0x26, 0xb2, 0x8d, 0x3a,
	0x7f, 0x40, 0x70, 0x3a, 0x37, 0xa8, 0xe0, 0xcf, 0x24, 0xf6, 0x8b, 0x85, 0x0d, 0xa5, 0x3e, 0x01,
	0xb5, 0xde, 0x9f, 0x45, 0x22, 0x71, 0x7f, 0x1e, 0xe3, 0x3e, 0x11, 0x71, 0x6d, 0xd4, 0xf9, 0x1b,
	0x82, 0x73, 0x53, 0xfa, 0x4b, 0xfc, 0x4a, 0x22, 0xbf, 0x3c, 0xbf, 0x15, 0x96, 0x07, 0x7e, 0x70,
	0xa4, 0x9e, 0x99, 0x94, 0xf0, 0x97, 0xb1, 0x16, 0x27, 0x2e, 0x5a, 0x79, 0x21, 0xd7, 0x39, 0xe5,
	0xbd, 0x30, 0xad, 0xb9, 0xd2, 0xcc, 0x56, 0xdc, 0x01, 0x16, 0x7b, 0xe1, 0xbf, 0x10, 0xd7, 0x46,
	0x9d, 0x9f, 0xc2, 0xe2, 0x4b, 0x77, 0xe0, 0x0d, 0x69, 0x84, 0xef, 0x25, 0x1d, 0x9a, 0x96, 0x3d,
	0x7a, 0x4f, 0xa7, 0x95, 0x3f, 0xbd, 0xb5, 0x13, 0x69, 0xa7, 0x1a, 0x96, 0x69, 0x9c, 0xab, 0x45,
	0x1d, 0x0f, 0x29, 0x3d, 0xbe, 0x0a, 0xd6, 0xc0, 0xdf, 0x38, 0x08, 0x58, 0x6f, 0x83, 0xbe, 0x75,
	0x47, 0x6c, 0x48, 0xc3, 0x98, 0xf2, 0x71, 0x63, 0x5b, 0x7e, 0x88, 0xc1, 0xcb, 0x46, 0xaf, 0x17,
	0xc4, 0xff, 0xf7, 0xb8, 0xf1, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x63, 0x4c, 0x25, 0x0b, 0x00,
	0x22, 0x00, 0x00,
}
